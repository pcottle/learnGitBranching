{
  "multiple-parents-name": "Здоровая семья, или несколько родителей",
  "multiple-parents-hint": "`git branch bugWork` на нужном коммите поможет создать нужную ссылку.",
  "multiple-parents-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Определение родителей",
            "",
            "Так же как тильда (~), каретка (^) принимает номер после себя.",
            "",
            "Но в отличие от количества коммитов, на которые нужно откатиться назад (как делает `~`), номер после `^` определяет, на какого из родителей мерджа надо перейти. Учитывая, что мерджевый коммит имеет двух родителей, просто указать ^ нельзя.",
            "",
            "Git по умолчанию перейдёт на \"первого\" родителя коммита, но указание номера после `^` изменяет это поведение.",
            "",
            "Посмотрим, как это работает.",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Вот мерджевый коммит. Если мы перейдём на `master^` без номера, то попадём на первого родителя.",
            "",
            "(*На нашей визуализации первый родитель находится прямо над коммитом*)"
          ],
          "afterMarkdowns": [
            "Просто - прямо как мы любим."
          ],
          "command": "git checkout master^",
          "beforeCommand": "git checkout HEAD^; git commit; git checkout master; git merge C2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Теперь попробуем перейти на второго родителя."
          ],
          "afterMarkdowns": [
            "Вот. Мы на втором родительском коммите."
          ],
          "command": "git checkout master^2",
          "beforeCommand": "git checkout HEAD^; git commit; git checkout master; git merge C2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Модификаторы `^` и `~` сильно помогают перемещаться по дереву коммитов:"
          ],
          "afterMarkdowns": [
            "Быстро как Флэш!"
          ],
          "command": "git checkout HEAD~; git checkout HEAD^2; git checkout HEAD~2",
          "beforeCommand": "git commit; git checkout C0; git commit; git commit; git commit; git checkout master; git merge C5; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Более того, эти модификаторы можно применять вместе. Например, так:"
          ],
          "afterMarkdowns": [
            "Сделаем то же самое, что перед этим, только в одну команду."
          ],
          "command": "git checkout HEAD~^2~2",
          "beforeCommand": "git commit; git checkout C0; git commit; git commit; git commit; git checkout master; git merge C5; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### На практике",
            "",
            "Чтобы пройти этот уровень, создай ветку в указанном месте.",
            "",
            "Очевидно, что (в данном случае) будет проще указать коммит напрямую, но для того, чтобы закрепить пройденное, используй модификаторы, о которых мы говорили выше."
          ]
        }
      }
    ]
  },
  "branching-name": "Ветвление в Git",
  "branching-hint": "Создай новую ветку при помощи \"git branch [name]\" и перейди на неё при помощи \"git checkout [name]\"",
  "branching-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Ветвление в Git",
            "",
            "Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру",
            "",
            "```",
            "делай ветки сразу, делай ветки часто",
            "```",
            "",
            "Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.",
            "",
            "Чуть позже мы попробуем использовать ветки и коммиты, и вы увидите, как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущих коммитов и всех его родителей."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Посмотрим, что такое ветки на практике",
            "",
            "Создадим здесь новую ветку с именем newImage"
          ],
          "afterMarkdowns": [
            "Вот и всё, ребята! Ветка newImage теперь указывает на коммит C1"
          ],
          "command": "git branch newImage",
          "beforeCommand": ""
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Теперь попробуем сделать некоторые изменения в этой ветке. Для этого нажми кнопку ниже."
          ],
          "afterMarkdowns": [
            "О-оу! Ветка master сдвинулась, тогда как ветка newImage - нет! Всё из-за того, что мы не переключились на новую ветку, а остались в старой, о чём говорит звёздочка около ветки master"
          ],
          "command": "git commit",
          "beforeCommand": "git branch newImage"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Сообщим Git, что хотим выбрать ветку",
            "",
            "```",
            "git checkout [name]",
            "```",
            "",
            "Эта команда перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения"
          ],
          "afterMarkdowns": [
            "Вот так! Наши изменения записаны уже в новую ветку"
          ],
          "command": "git checkout newImage; git commit",
          "beforeCommand": "git branch newImage"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ну что ж, теперь ты готов к работе с ветками. Как только это окно закроется,",
            "создай ветку с именем bugFix и переключись на неё"
          ]
        }
      }
    ]
  },
  "commits-name": "Знакомство с Git Commit ",
  "commits-hint": "Попробуй дважды выполнить команду 'git commit' ;)",
  "commits-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Коммиты в GIT",
            "Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше",
            "",
            "Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит в набор изменений или «дельту» между текущей версией и предыдущей.",
            "",
            "Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом!",
            "",
            "Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта. Коммиты очень легки, так что переключение между ними происходит предельно быстро!"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Посмотрим, как это выглядит на практике. Справа расположена визуализация небольшого git репозитория. Сейчас в нём два коммита: первый, исходный коммит С0 и один коммит С1 после него, содержащий изменения.",
            "",
            "Нажми на кнопку, чтобы совершить коммит"
          ],
          "afterMarkdowns": [
            "Отлично. Мы только что внесли изменения в репозиторий и сохранили их как коммит. У коммита, который мы только что сделали, есть родитель, С1, который указывает на предыдущий коммит."
          ],
          "command": "git commit",
          "beforeCommand": ""
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Пора попробовать! После того, как это окно закроется, сделай два коммита, чтобы пройти этот уровень."
          ]
        }
      }
    ]
  },
  "merging-name": "Слияния веток в Git",
  "merging-hint": "Не забудь делать коммиты в правильном порядке (сначала bugFix, потом master)",
  "merging-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Ветки и слияния",
            "",
            "Ок! Мы уже знаем, как создавать ветки и коммитить наши изменения. Теперь надо понять, как объединять изменения из двух разных веток. Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими.",
            "",
            "Первый способ объединения изменений, который мы рассмотрим - это `git merge` - слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами.",
            "",
            "Слишком запутанно =) На схеме всё проще и понятнее."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Вот у нас две ветки, каждая содержит по одному уникальному коммиту. Это означает, что ни одна из веток не содержит полный набор \"работ\", выполненных в этом репозитории. Можно исправить эту ситуацию, выполнив слияние.",
            "",
            "Мы сделаем `merge` ветки `bugFix` в ветку `master`"
          ],
          "afterMarkdowns": [
            "Что мы видим? Во-первых, ветка `master` теперь указывает на коммит, у которого два родителя. Если проследовать по стрелкам от этого коммита, вы пройдёте через каждый коммит в дереве прямиком к началу. Это означает, что теперь в ветке `master` содержатся все изменения репозитория.",
            "",
            "Во-вторых, обрати внимание, как изменились цвета коммитов. Мы ввели цветовую дифференциацию, чтобы помочь пониманию. У каждой ветки — свой цвет. Каждый коммит становится того цвета, какого его ветка. Если в нём изменения сразу двух веток - он становится цветом, смешанным из цветов родительских веток.",
            "",
            "И вот мы видим, что цвет ветки `master` подмешан к каждому коммиту, а ветки `bugFix` - нет. Это можно поправить."
          ],
          "command": "git merge bugFix",
          "beforeCommand": "git checkout -b bugFix; git commit; git checkout master; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Смерджим ветку `master` в ветку `bugFix`"
          ],
          "afterMarkdowns": [
            "Так как ветка `bugFix` была предшественницей `master`, Git не делал ничего, только сдвинул `bugFix` на тот же коммит, где находится `master`",
            "",
            "Теперь все коммиты одного цвета, что означает, что каждая ветка содержит все изменения репозитория! Поздравляем!"
          ],
          "command": "git checkout bugFix; git merge master",
          "beforeCommand": "git checkout -b bugFix; git commit; git checkout master; git commit; git merge bugFix"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, сделай следующее:",
            "",
            "* Создай новую ветку под названием `bugFix`",
            "* Переключись на новую ветку `bugFix` командой `git checkout bugFix`",
            "* Сделай один коммит",
            "* Вернись на ветку `master` при помощи `git checkout`",
            "* Сделай ещё один коммит",
            "* Слей ветку `bugFix` с веткой `master` при помощи `git merge`",
            "",
            "* Если что-то пошло не так - можешь подглядеть в эту шпаргалку командой \"objective\"!*"
          ]
        }
      }
    ]
  },
  "rebasing-name": "Введение в rebase",
  "rebasing-hint": "Убедись, что сделал коммит в ветке bugFix",
  "rebasing-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Rebase",
            "",
            "Второй способ объединения изменений в ветках - это *rebasing*. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.",
            "",
            "Несмотря на то, что это звучит достаточно непонятно, преимущество `rebase` в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете `rebase`.",
            "",
            "Посмотрим, как это работает..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "У нас здесь снова две ветки. Обрати внимание, что выбрана ветка `bugFix` (отмечена звёздочкой)",
            "",
            "Хочется сдвинуть наши изменения из `bugFix` прямо на вершину ветки `master`. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.",
            "",
            "Применим `git rebase`"
          ],
          "afterMarkdowns": [
            "Супер! Теперь изменения из `bugFix` находятся в конце ветки `master` и являют собой линейную последовательность коммитов.",
            "",
            "Обрати внимание, что коммит С3 до сих пор существует где-то, а С3' - это его \"копия\" в ветке `master`",
            "",
            "Единственная проблема - ветка `master` не обновлена до последних изменений. Это легко исправить."
          ],
          "command": "git rebase master",
          "beforeCommand": "git commit; git checkout -b bugFix C1; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Вот мы выбрали ветку `master`. Вперёд - сделаем rebase на `bugFix`"
          ],
          "afterMarkdowns": [
            "Вуаля! Так как `master` был предком `bugFix`, git просто сдвинул ссылку на `master` вперёд."
          ],
          "command": "git rebase bugFix",
          "beforeCommand": "git commit; git checkout -b bugFix C1; git commit; git rebase master; git checkout master"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, сделай следующее:",
            "",
            "* Переключись на ветку `bugFix`",
            "* Сделай коммит",
            "* Вернись на `master` и сделай коммит ещё раз",
            "* Переключись на `bugFix` и сделай rebase на `master`",
            "",
            "Удачи!"
          ]
        }
      }
    ]
  },
  "describe-name": "Git describe",
  "describe-hint": "Когда закончишь, просто сделай commit",
  "describe-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Git Describe",
            "",
            "Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состоянии от ближайшего тега. И эта команда называется `git describe`",
            "",
            "Git describe помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали `git bisect` или если вы недавно вернулись из отпуска =)"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Git describe выглядит примерно так:",
            "",
            "`git describe <ref>`",
            "",
            "Где `ref` — это что-либо, что указывает на конкретный коммит. Если не указать `ref`, то git будет считать, что указано текущее положение (`HEAD`).",
            "",
            "Вывод команды выглядит примерно так:",
            "",
            "`<tag>_<numCommits>_g<hash>`",
            "",
            "Где `tag` – это ближайший тег в истории изменений, `numCommits` – это на сколько далеко мы от этого тега, а `hash` – это хеш коммита, который описывается."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Посмотрим на простой пример. Для дерева, показанного ниже:"
          ],
          "afterMarkdowns": [
            "Команда `git describe master` выведет:",
            "",
            "`v1_2_gC2`",
            "",
            "Тогда как `git describe side` выведет:",
            "",
            "`v2_1_gC4`"
          ],
          "command": "git tag v2 C3",
          "beforeCommand": "git commit; go -b side HEAD~1; gc; gc; git tag v1 C0"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Это, в общем-то, всё, что можно сказать про `git describe`. Попробуй выполнить команду на нескольких коммитах.",
            "",
            "Как только наиграешься, просто сделай один коммит, и уровень будет пройден."
          ]
        }
      }
    ]
  },
  "grabbing-one-commit-name": "Выберем один коммит.",
  "grabbing-one-commit-hint": "Не забывай, что интерактивный rebase и cherry-pick – это твои друзья!",
  "grabbing-one-commit-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Вот ситуация, которая часто случается при разработке: мы пытаемся отследить ошибку, но она не очень очевидна. Для того, чтобы достичь успеха на этом поприще, мы используем несколько команд для отладки и вывода",
            "",
            "Каждая отладочная команда (команды) вывода находится в своём коммите. В итоге мы нашли ошибку, исправили её и порадовались!",
            "",
            "Но проблема в том, что мы хотим добавить в `master` только исправление ошибки из ветки `bugFix`. Если мы воспользуемся простым fast-forward, то в `master` попадут также отладочные команды. Должен быть другой способ..."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Надо заставить git копировать только один из коммитов. Это почти как в предыдущем уровне – мы можем использовать уже известные нам команды: ",
            "",
            "* `git rebase -i`",
            "* `git cherry-pick`",
            "",
            "Чтобы достичь желаемого результата."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "В этом уровне тебе решать, какую команду использовать, но чтобы закончить уровень, убедись, что в мастер попал коммит, на который ссылается `bugFix`"
          ]
        }
      }
    ]
  },
  "juggling-commits-name": "Жонглируем коммитами",
  "juggling-commits-hint": "Первой командой должна быть git rebase -i HEAD~2",
  "juggling-commits-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Жонглируем коммитами",
            "",
            "Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (`newImage`) и другие изменения (`caption`), которые связаны так, что находятся друг поверх друга в репозитории.",
            "",
            "Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять `newImage`, несмотря на то, что коммит уже в прошлом!"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Преодолеть эти трудности можно следующим образом:",
            "",
            "* Переставить коммит так, чтобы нужный находился наверху при помощи `git rebase -i`",
            "* Внести изменения при помощи `commit --amend`",
            "* Переставить всё обратно при помощи `git rebase -i`",
            "* И наконец, переместить master на изменённую часть дерева, чтобы закончить уровень.",
            "",
            "Это задание можно выполнить несколькими способами (и, гляжу, ты посматриваешь на cherry-picking), но сейчас сосредоточься на вышеописанном методе.",
            "",
            "Обрати внимание на итоговое состояние в этом уровне – так как мы дважды перемещаем коммиты, оба они получат по апострофу. Ещё один апостроф добавляется, когда мы делаем `commit --amend`.",
            "",
            "Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов."
          ]
        }
      }
    ]
  },
  "juggling-commits2-name": "Жонглируем коммитами №2",
  "juggling-commits2-hint": "Не забудь переместить master на последние изменения.",
  "juggling-commits2-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Жонглируем коммитами №2",
            "",
            "*Перед прохождением этого уровня обязательно надо пройти предыдущий уровень – 'Жонглируем коммитами №1'*",
            "",
            "В прошлом уровне мы использовали `rebase -i`, чтобы переставлять коммиты. Как только нужный нам коммит оказывался в конце, мы могли спокойно изменить его при помощи `--amend` и переставить обратно.",
            "",
            "Единственная проблема тут - это множество перестановок, которые могут спровоцировать конфликты. Посмотрим, как с этой же задачей справится cherry-pick."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Важно помнить, что cherry-pick поместит любой коммит сразу после HEAD (только если этот коммит не является предком HEAD)",
            "",
            "Вот небольшое демо для напоминания:"
          ],
          "afterMarkdowns": [
            "Ок! Едем дальше!"
          ],
          "command": "git cherry-pick C2",
          "beforeCommand": "git checkout -b bugFix; git commit; git checkout master; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Итак, в этом уровне нужно достичь того же эффекта, но без использования `rebase -i`. Остальное – по усмотрению.",
            "",
            "Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов."
          ]
        }
      }
    ]
  },
  "tags-name": "git tag",
  "tags-hint": "Можно сделать checkout напрямую на коммит или же на тег",
  "tags-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Теги",
            "",
            "В прошлых уроках мы усвоили, что ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние.",
            "",
            "В таком случае, где взять *постоянную* ссылку на момент в истории изменений? Для таких вещей, как релиз, большие слияния нужно нечто более постоянное, чем ветка.",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.",
            "",
            "Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений",
            "",
            "Посмотрим на это на практике."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Создадим тег на `C1`, который будет нашей версией 1"
          ],
          "afterMarkdowns": [
            "Готово! Всё просто. Мы назвали тег `v1` и заставили его ссылаться на `C1` явным образом. Если конкретный коммит не указан, гит пометит тегом `HEAD`"
          ],
          "command": "git tag v1 C1",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, просто создай теги так, как показано на визуализации, и потом перейди на тег `v1`. Обрати внимание, что ты перейдёшь в состояние `detached HEAD`, так как нельзя сделать коммит прямо в тег `v1`.",
            "",
            "В следующем уровне мы попробуем более интересные способы применения тегов."
          ]
        }
      }
    ]
  },
  "cherry-pick-name": "Введение в Cherry-pick",
  "cherry-pick-hint": "git cherry-pick основывается на именах коммитов!",
  "cherry-pick-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Поперемещаем изменения",
            "",
            "Итак, мы уже освоили основы Git: коммиты, ветки, перемещение по дереву изменений. Уже этих знаний достаточно, чтобы овладеть 90% мощью Git-репозиториев и покрыть нужды разработчиков.",
            "",
            "А оставшиеся 10% будут очень полезны при сложных workflow (или если ты попал в сложную ситуацию). Теперь речь пойдёт о перемещении изменений — возможности, позволяющей разработчику сказать \"Хочу, чтобы эти изменения были вот тут, а вот эти — вон там\" и получить точные, правильные результаты, не теряя при этом гибкости разработки.",
            "",
            "На первый взгляд запутанно, но на самом деле всё просто."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Cherry-pick",
            "",
            "Первая из таких команд - это `git cherry-pick`. Она выглядит вот так:",
            "",
            "* `git cherry-pick <Commit1> <Commit2> <...>`",
            "",
            "Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (`HEAD`). Мы обожаем `cherry-pick` за то, что в нём очень мало магии и его очень просто понять и применять.",
            "",
            "Посмотрим на демонстрацию.",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Вот репозиторий, где есть некие изменения в ветке `side`, которые мы хотим применить и в ветку `master`. Мы можем сделать это при помощи команды rebase, которую мы уже прошли, но давай посмотрим, как cherry-pick справится с этой задачей."
          ],
          "afterMarkdowns": [
            "Вуаля! Мы хотели перенести коммиты `C2` и `C4`, Git дал нам их там, где они нужны. Всё просто!"
          ],
          "command": "git cherry-pick C2 C4",
          "beforeCommand": "git checkout -b side; git commit; git commit; git commit; git checkout master; git commit;"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, просто скопируй изменения из этих трёх веток в мастер. Чтобы понять, какие коммиты копировать, посмотри на визуализацию уровня.",
            ""
          ]
        }
      }
    ]
  },
  "detached-head-name": "Теряем голову, или detached HEAD",
  "detached-head-hint": "Ориентируйся по идентификаторам (hash) коммитов.",
  "detached-head-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Прогулка по Git",
            "",
            "Прежде чем перейти к более продвинутым фичам Git, важно понять различные способы перемещения по дереву коммитов вашего проекта.",
            "",
            "Как только вы научитесь свободно передвигаться по дереву коммитов, ваши возможности в Git приумножатся.",
            "",
            "",
            "",
            "",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## HEAD",
            "",
            "В первую очередь, поговорим о \"HEAD\". HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.",
            "",
            "HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.",
            "",
            "Обычно HEAD указывает на имя ветки (например, `bugFix`). Когда вы делаете коммит, статус ветки `bugFix` меняется и это изменение видно через HEAD."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Посмотрим, как это работает. Обратите внимание на то, где находится HEAD до и после коммита."
          ],
          "afterMarkdowns": [
            "Вот! HEAD всё это время скрывался за веткой `master`."
          ],
          "command": "git checkout C1; git checkout master; git commit; git checkout C2",
          "beforeCommand": ""
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "### Detaching HEAD",
            "",
            "Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту. Посмотрим, что было до отделения:",
            "",
            "HEAD -> master -> C1",
            ""
          ],
          "afterMarkdowns": [
            "А вот что получилось теперь",
            "",
            "HEAD -> C1"
          ],
          "command": "git checkout C1",
          "beforeCommand": ""
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти уровень, давай отделим HEAD от ветки `bugFix` и присвоим его последнему коммиту в этой же ветке.",
            "",
            "Укажи коммит при помощи его идентификатора (hash). Hash для каждого коммита указан в кружке на схеме."
          ]
        }
      }
    ]
  },
  "interactive-rebase-name": "Введение в интерактивный Rebase",
  "interactive-rebase-hint": "Можно использовать либо ветки, либо относительные ссылки (HEAD~), чтобы указать цель для Rebase",
  "interactive-rebase-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Interactive Rebase",
            "",
            "Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)",
            "",
            "Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.",
            "",
            "Углубимся в детали."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Всё, что нужно для интерактивного rebase - это опция `-i`",
            "",
            "Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.",
            "",
            "Для \"реального\" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "После открытия окна интерактивного rebase есть три варианта для каждого коммита:",
            "",
            "* Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).",
            "* Можно \"выкинуть\" коммит из ребейза. Для этого есть `pick` - переключение его означает, что нужно выкинуть коммит.",
            "* Наконец, можно соединить коммиты. В этом уровне игры у нас не реализована эта возможность, но, вкратце, при помощи этой функции можно объединять изменения двух коммитов.",
            "",
            "Ну что ж, посмотрим на примеры!"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "После нажатия на эту кнопку появится окно интерактивного rebase. Переставь несколько коммитов (или удали кое-какие) и посмотри, что получится в итоге!"
          ],
          "afterMarkdowns": [
            "Бах! Git скопировал коммиты в точности так, как было указано через интерфейс!"
          ],
          "command": "git rebase -i HEAD~4 --aboveAll",
          "beforeCommand": "git commit; git commit; git commit; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, переставь коммиты при помощи интерактивного rebase в таком порядке, как указано на визуализации. На всякий случай, помни, что всегда можно исправить ошибку, вызвав команду undo или reset."
          ]
        }
      }
    ]
  },
  "relative-refs-name": "Относительные ссылки (^)",
  "relative-refs-hint": "Не забудь оператор `^`",
  "relative-refs-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Относительные ссылки",
            "",
            "Передвигаться по дереву Git при помощи указания хешей коммитов немного неудобно. В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что придётся каждый раз использовать `git log`, чтобы найти хеш нужного коммита",
            "",
            "Более того, хеши в реальном репозитории Git намного более длинные. Например, хеш для коммита, который приведён в предыдущем уровне - `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`. Не очень просто для произношения =)",
            "",
            "Хорошая новость в том, что Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто `fed2` вместо колбасы выше."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Как мы уже говорили, указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки и они прекрасны!",
            "",
            "С относительными ссылками можно начать с какого-либо удобного места (например, с ветки `bugFix` или от HEAD) и двигаться от него",
            "",
            "Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:",
            "",
            "* Перемещение на один коммит назад `^`",
            "* Перемещение на <num> коммитов назад `~<num>`"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Для начала рассмотрим оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.",
            "",
            "Так что `master^` означает \"первый предок ветки `master`\".",
            "",
            "`master^^` означает предок предка ветки `master`",
            "",
            "Получим предка ветки `master` на практике"
          ],
          "afterMarkdowns": [
            "Опачки! Готово. Сильно проще, чем поиск и указание хеша."
          ],
          "command": "git checkout master^",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Можно также использовать `HEAD` как относительную ссылку. Попробуем пройти несколько раз назад по дереву коммитов"
          ],
          "afterMarkdowns": [
            "Изи! Мы можем путешествовать во времени при помощи `HEAD^`"
          ],
          "command": "git checkout C3; git checkout HEAD^; git checkout HEAD^; git checkout HEAD^",
          "beforeCommand": "git commit; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, переместись на первого родителя ветки `bugFix`. Это отделит `HEAD` от ветки.",
            "",
            "Конечно, можно указать хеш, но надо попробовать использовать относительные ссылки!"
          ]
        }
      }
    ]
  },
  "relative-refs2-name": "Относительные ссылки №2",
  "relative-refs2-hint": "Понадобится использовать как минимум одну прямую ссылку (хеш), чтобы пройти этот уровень",
  "relative-refs2-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Оператор \"~\"",
            "",
            "Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать `^` несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~).",
            "",
            "",
            "К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. Посмотрим, как это работает."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Укажем после `~` число коммитов, через которые надо пройти."
          ],
          "afterMarkdowns": [
            "Оп! Очевидно, относительные ссылки прекрасны."
          ],
          "command": "git checkout HEAD~4",
          "beforeCommand": "git commit; git commit; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Перемещение ветки (branch forcing)",
            "",
            "Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.",
            "",
            "Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции `-f`. Например, команда:",
            "",
            "`git branch -f master HEAD~3`",
            "",
            "Переместит (принудительно) ветку `master` на три родителя назад от `HEAD`."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Посмотрим, как работает эта команда"
          ],
          "afterMarkdowns": [
            "Вуаля! Относительная ссылка дала нам возможность просто сослаться на `C1`, а branch forcing (`-f`) позволил быстро переместить указатель ветки на этот коммит."
          ],
          "command": "git branch -f master HEAD~3",
          "beforeCommand": "git commit; git commit; git commit; git checkout -b bugFix"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Мы рассмотрели относительные ссылки и branch forcing вкупе, так что теперь пришло время пройти следующий уровень.",
            "",
            "Чтобы пройти этот уровень, передвинь `HEAD`, `master` и `bugFix` так, как показано на визуализации."
          ]
        }
      }
    ]
  },
  "reversing-changes-name": "Отмена изменений в Git",
  "reversing-changes-hint": "Обрати внимание, что revert и reset принимают разные параметры.",
  "reversing-changes-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Отмена изменений в Git",
            "",
            "Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.",
            "",
            "Есть два основных способа отмены изменений в Git: первый - это `git reset`, а второй - `git revert`. Попробуем оба на следующем шаге.",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "## Git Reset",
            "",
            "`git reset` отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода \"переписывание истории\"; `git reset` перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.",
            "",
            "Посмотрим, как это работает:"
          ],
          "afterMarkdowns": [
            "Неплохо! Git просто перенёс ссылку на `master` обратно на коммит `C1`. Теперь наш локальный репозиторий в состоянии, как будто `C2` никогда не существовал."
          ],
          "command": "git reset HEAD~1",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "## Git Revert",
            "",
            "Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.",
            "",
            "Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать `git revert`. Посмотрим, как это работает"
          ],
          "afterMarkdowns": [
            "Забавно, появился новый коммит. Дело в том, что новый коммит `C2'` просто содержит изменения, полностью противоположные тем, что сделаны в коммите `C2`.",
            "",
            "После `revert` можно сделать `push` и поделиться изменениями с остальными."
          ],
          "command": "git revert HEAD",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, отмени два последних коммита и в `local`, и в `pushed`",
            "",
            "Помни, что `pushed` - это remote ветка, а `local` - это локальная ветка. Это поможет выбрать способ отмены изменений."
          ]
        }
      }
    ]
  },
  "many-rebases-name": "Rebase over 9000 раз",
  "many-rebases-hint": "Не забудь, что лучше всего сдвинуть мастер в самом конце...",
  "many-rebases-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Rebase на нескольких ветках",
            "",
            "У нас тут куча веток! Было бы круто перенести все изменения из них в мастер.",
            "",
            "Но начальство усложняет нашу задачу тем, что желает видеть все коммиты по порядку. Так что коммит `С7'` должен идти после коммита `С6'` и так далее.",
            "",
            "Если что-то пойдёт не так – не надо стесняться использовать `reset`, чтобы начать всё с чистого листа. Постарайся сделать как можно меньше манипуляций!"
          ]
        }
      }
    ]
  },
  "selective-rebase-name": "Спутанные ветки",
  "selective-rebase-hint": "Убедись, что у нас всё по порядку! Сначала ветка `one`, потом `two` и только потом `three`",
  "selective-rebase-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Спутанные ветки",
            "",
            "УОУ! В этом уровне придётся попотеть!",
            "",
            "У нас тут по несколько коммитов в ветках `one`, `two` и `three`. Не важно почему, но нам надо видоизменить эти три ветки при помощи более поздних коммитов из ветки `master`.",
            "",
            "Ветка `one` нуждается в изменении порядка и удалении `C5`. `two` требует полного перемешивания, а `three` хочет получить только один коммит",
            "",
            "Как пройти этот уровень – решать тебе, а как найдёшь решение – сравни его с нашим при помощи `show solution`."
          ]
        }
      }
    ]
  },
  "clone-name": "Введение в клонирование",
  "clone-hint": "Простой git clone!",
  "clone-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Удалённые репозитории в Git",
            "",
            "На самом деле удалённые репозитории в Git не так сложны, как кажутся на первый взгляд. Кажется, что в современном мире облачных вычислений под термином «удалённый репозиторий» подразумевается что-то сложное и загадочное. Однако, удалённые репозитории — это всего-навсего копии вашего репозитория, хранящиеся на другом компьютере. Обычно вы можете связываться с этим другим компьютером через Интернет, что позволяет вам передавать коммиты туда и сюда.",
            "",
            "Как уже было сказано, удалённые репозитории обладают рядом замечательных свойств:",
            "",
            "- В первую очередь, удалённые репозитории - это замечательное средство резервного копирования! Насколько вам известно, локальные репозитории способны восстанавливать файлы, используя предыдущие состояния, но вся эта информация хранится локально. Потеряв все свои локальные данные, вы способны восстановить их при наличии копии своего репозитория на другом компьютере.",
            "",
            "- Что ещё более важно, удалённые репозитории позволяют сделать процесс разработки более социальным! Теперь, когда копия вашего проекта размещена в другом месте, ваши друзья запросто могут внести свой вклад в ваш проект или забрать последние и актуальные изменения.",
            "",
            "Набирает популярность использование web-сайтов для визуализации активности удалённых репозиториев (например, [GitHub](https://github.com/) или [Phabricator](http://phabricator.org/)), однако удалённые репозитории _всегда_ выступают в качестве базы для таких инструментов. Поэтому так важно понимать, как устроены удалённые репозитории!"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Наша команда для создания удалённого репозитория",
            "",
            "До настоящего момента мы были сфокусированы на изучении основ работы с _локальным_ репозиторием (ветвление, слияние, перемещение и т.д.). Однако теперь, когда мы хотим научиться работать с удалёнными репозиториями, нам нужны новые команды для настройки рабочей среды для этих упражнений. Такой командой нам послужит `git clone`",
            "",
            "Технически, `git clone` в реальной жизни - это команда, которая создаст _локальную_ копию удалённого репозитория (например, с GitHub). На наших занятиях в Learn Git Branching мы используем эту команду немного иначе - `git clone` создаёт удалённый репозиторий на основе вашего локального репозитория. На самом деле, это является полной противоположностью реальной команды, однако такой подход поможет нам наладить связь между склонированным и удалённым репозиторием. Давайте просто запустим эту команду.",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте начнём постепенное изучение и взглянем на то, что собой представляет удалённый репозиторий (в нашем представлении).",
            ""
          ],
          "afterMarkdowns": [
            "Вот так! Теперь у нас есть удалённый репозиторий нашего проекта. Выглядит всё довольно одинаковым за исключением некоторых визуальных различий - в последующих уровнях вы увидите, как мы разделяем работу по этим репозиториям."
          ],
          "command": "git clone",
          "beforeCommand": ""
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы завершить уровень, просто выполните `git clone` на своём существующем репозитории. Настоящее обучение появится в последующих уроках."
          ]
        }
      }
    ]
  },
  "fake-teamwork-name": "Коллективная работа",
  "fake-teamwork-hint": "помните, Вы можете указать количество фейковых коммитов",
  "fake-teamwork-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Симуляция совместной работы",
            "",
            "В данном уроке мы находимся в немного затруднительном положении - для выполнения ряда упражнений нам нужно обучить вас скачивать наработки и изменения, которые были сделаны в удалённом репозитории.",
            "",
            "Это означает, что нам следует \"сделать вид\", как будто мы знаем о том, что наш удалённый репозиторий, с которым мы работаем, был изменён одним из ваших коллег / друзей / единомышленников. Это может быть какая-то ветка, либо же какой-то конкретный коммит.",
            "",
            "Для того, чтобы добиться своих целей, нам предоставляется команда со звучным именем `git fakeTeamwork`! Имя команды однозначно даёт понять, что она выполняет. Давайте ознакомимся с демо..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Поведение команды `fakeTeamwork` по умолчанию заключается в том, чтобы просто \"инициировать\" коммит на master-е"
          ],
          "afterMarkdowns": [
            "Ну вот - удалённый репозиторий был изменён при помощи добавления нового коммита, и мы ещё не скачали этот коммит, потому что не запустили команду `git fetch`."
          ],
          "command": "git fakeTeamwork",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "В данной команде вам доступна возможность указать ветку и количество добавляемых коммитов"
          ],
          "afterMarkdowns": [
            "С помощью одной лишь команды мы симулируем добавление трёх коммитов в ветку `foo` на удалённом репозитории"
          ],
          "command": "git fakeTeamwork foo 3",
          "beforeCommand": "git branch foo; git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Последующие уровни будут довольно сложными, поэтому в этом упражнении от вас больше ничего не требуется.",
            "",
            "Вперёд! Склонируйте удалённый репозиторий (с помощью `git clone`), симулируйте любые изменения на этом удалённом репозитории, сделайте какие-нибудь свои коммиты и затем скачайте \"чужие\" изменения. Это выглядит как несколько уроков в одном!"
          ]
        }
      }
    ]
  },
  "fetch-name": "Git fetch",
  "fetch-hint": "Просто выполните git fetch!",
  "fetch-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Fetch",
            "",
            "Работа с удалёнными git репозиториями сводится к передаче данных _в_ и _из_ других репозиториев. До тех пор, пока мы можем отправлять коммиты туда-обратно, мы можем делиться любыми изменениями, которые отслеживает git (следовательно, делиться новыми файлами, свежими идеями, любовными письмами и т.д.).",
            "",
            "В этом уроке вы научитесь тому, как извлекать данные _из_ удалённого репозитория - и для этого у нас есть соответствующая команда `git fetch`.",
            "",
            "Вы увидите, что как только мы изменим представление нашего удалённого репозитория, наши _удалённые_ ветки обновятся соответствующим образом и отобразят это представление. Это связывает воедино предыдущий урок про удалённые репозитории."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Прежде чем углубляться в детали команды `git fetch`, давайте взглянем на её визуализацию в действии! Здесь у нас имеется удалённый репозиторий, который содержит в себе два коммита, отсутствующих в нашем локальном репозитории."
          ],
          "afterMarkdowns": [
            "Вот и всё! Коммиты `C2` и `C3` были успешно скачаны в наш локальный репозиторий, и наша удалённая ветка `o/master` отобразила эти изменения соответствующим образом."
          ],
          "command": "git fetch",
          "beforeCommand": "git clone; git fakeTeamwork 2"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Что делает fetch",
            "",
            "`git fetch` выполняет две и только две основные операции. А именно:",
            "",
            "* связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...",
            "* у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, `o/master`)",
            "",
            "Фактически, `git fetch` синхронизирует _локальное_ представление удалённых репозиториев с тем, что является _актуальным_ на текущий момент времени.",
            "",
            "Насколько вы помните, в предыдущем уроке мы сказали, что удалённые ветки отображают состояние удалённых репозиториев _на тот момент_ когда вы 'общались' с ними в последний раз. `git fetch` является тем механизмом, который даёт вам возможность общаться с удалёнными репозиториями! Надеюсь, что связь между удалёнными ветками и командой `git fetch` теперь прояснилась.",
            "",
            "`git fetch` обычно 'общается' с удалёнными репозиториями посредством Интернета (через такие протоколы, как `http://` или `git://`).",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Чего fetch не делает",
            "",
            "Важно отметить, что команда `git fetch` забирает данные в ваш _локальный_ репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.",
            "",
            "Важно это помнить и понимать, потому что многие разработчики думают, что, запустив команду `git fetch`, они приведут всю свою локальную работу к такому же виду, как и на удалённом репозитории. Команда всего лишь скачивает все необходимые данные, но вам потребуется вручную слить эти данные с вашими, когда вы будете готовы. В следующих уроках мы научимся это делать :D",
            "",
            "Одним словом, вы можете относиться к `git fetch` как к процедуре скачивания."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы выполнить уровень, просто запустите `git fetch` и скачайте все коммиты!"
          ]
        }
      }
    ]
  },
  "fetch-args-name": "Аргументы для fetch",
  "fetch-args-hint": "Обратите внимание на то, как номера коммитов могут меняться! Вы можете прочесть слайды вновь, воспользовавшись командой \"help level\"",
  "fetch-args-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Аргументы git fetch",
            "",
            "Итак, мы только что изучили всё, что касается аргументов git push, мы узнали о параметре `<пункт назначения>`, и даже об аргументе, задающем отдельно источник и получатель коммитов (`<источник>:<получатель>`). Можем ли мы применить все эти полученные знания для команды `git fetch` ?",
            "",
            "Ещё бы! Аргументы для команды `git fetch` на самом деле *очень, очень* похожи на те, что мы использовали в `git push`. В данном случае применяется тот же подход, только в противоположном направлении (так как теперь вы скачиваете коммиты, а не закачиваете их).",
            "",
            "Давайте ознакомимся с принципами один за одним..."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Параметр `<пункт назначения>`",
            "",
            "Если вы указываете пункт назначения в команде git fetch, например так, как в следующем примере:",
            "",
            "`git fetch origin foo`",
            "",
            "Git отправится в ветку `foo` на удалённом репозитории, соберёт с собой все коммиты, которые не присутствуют локально, и затем поместит их в локальную ветку под названием `o/foo`.",
            "",
            "Давайте взглянем на всё это в действии (чтобы освежить в памяти)."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Указывая пункт назначения..."
          ],
          "afterMarkdowns": [
            "мы скачиваем только коммиты с ветки `foo` и помещаем их в `o/foo`"
          ],
          "command": "git fetch origin foo",
          "beforeCommand": "git branch foo; git clone; git fakeTeamwork foo 2"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Вы, должно быть, спрашиваете себя — зачем git поместил эти коммиты в ветку `o/foo` вместо того, чтобы разместить их в локальной ветке `foo` ? Ведь я думал о параметре `<пункт назначения>`, как о месте, ветке, которая существует в обоих - локальном и удалённом репозитории. Верно?",
            "",
            "На самом деле, в данном случае git делает исключение, потому что вы, возможно, работаете над веткой `foo`, которую не хотите привести в беспорядок!! Об этом упоминалось в ранних уроках по `git fetch` - эта команда не обновляет ваши локальные 'не удалённые', она лишь скачивает коммиты (соответственно, вы можете инспектировать / объединять их позже).",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "\"Что же тогда произойдёт, если я явно укажу оба параметра: и источник и получатель, пользуясь синтаксисом `<источник>:<получатель>` ?\"",
            "",
            "Если вы уверены в том, что хотите закачать коммиты *прямиком* в вашу локальную ветку, тогда да, вы можете явно указать источник и получатель через двоеточние. Вы можете воспользоваться таким приёмом лишь для ветки, на которой вы не находитесь в настоящий момент `checkout`.",
            "",
            "Теперь у нас `<источник>` - это место на *удалённом репозитории*, а `<получатель>` - место в *локальном* репозитории, в который следует помещать коммиты. Аргументы в точности до наоборот повторяют git push, и немудрено, ведь теперь мы переносим данные в обратном направлении!",
            "",
            "Как уже было сказано, разработчики редко используют такой подход на практике. Целью демонстрации этой возможности было показать, насколько схожи концептуально `fetch` и `push`. Их отличие лишь в направлении переноса данных."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте взглянем на всё это в действии:"
          ],
          "afterMarkdowns": [
            "Ого! Видите, git распознал `foo~1` как место в origin и затем скачал эти коммиты в `bar`, которая является локальной веткой. Обратите внимание, что ветки `foo` и `o/foo` не изменились, так как в аргументах мы явно указали получателя."
          ],
          "command": "git fetch origin foo~1:bar",
          "beforeCommand": "git branch foo; git clone; git branch bar; git fakeTeamwork foo 2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А что, если ветка-получатель не существует на момент запуска команды? Давайте ещё раз взглянем на предыдущий слайд, но на этот раз ветки `bar` ещё не существует."
          ],
          "afterMarkdowns": [
            "Видите, поведение совсем такое же, как и у git push. Git создал ветку-получатель локально прежде чем скачивать данные. Всё как и в случае, когда git создаёт получателя в удалённом репозитории, когда мы закачиваем изменения (если получатель не существует)."
          ],
          "command": "git fetch origin foo~1:bar",
          "beforeCommand": "git branch foo; git clone; git fakeTeamwork foo 2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А если вообще без аргументов ?",
            "",
            "Если команда `git fetch` выполняется без аргументов, она скачивает все-все коммиты с удалённого репозитория и помещает их в соответствующие удалённо-локальные ветки в локальном репозитории..."
          ],
          "afterMarkdowns": [
            "Достаточно просто, после того как мы пережили все эти технические тонкости."
          ],
          "command": "git fetch",
          "beforeCommand": "git branch foo; git clone; git fakeTeamwork foo; git fakeTeamwork master"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ладно, достаточно болтовни! Чтобы выполнить этот уровень, скачайте лишь определённые коммиты так, как представлено в визуализации цели. Пофантазируйте с этими командами!",
            "",
            "Вам следует явно указывать источник и получателя для обеих команд fetch. Обратите внимание на визуализацию цели, так как ID-шники могут меняться!"
          ]
        }
      }
    ]
  },
  "fetch-rebase-name": "Расхождение в истории",
  "fetch-rebase-hint": "проверьте сортировку в визуализации цели",
  "fetch-rebase-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Когда наработки расходятся",
            "",
            "Вот мы и познакомились с тем, как забирать (`pull`) чужие коммиты и как закачивать (`push`) свои наработки и изменения. Выглядит всё довольно просто, и не ясно какие же могут возникать у людей трудности со всем этим?",
            "",
            "Сложности возникают тогда, когда история репозитория *расходится*. Прежде чем идти дальше, давайте посмотрим на пример...",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Представьте себе, вы склонировали репозиторий в понедельник и начали разрабатывать какую-то новую и уникальную часть приложения (на сленге разработчиков - `фича`). В пятницу вечером вы наконец-то готовы опубликовать вашу фичу. Но, о нет! Ваш коллега в течение недели написал кучу кода, который делает все ваши наработки устарелыми. Этот код был также закоммичен и опубликован на общедоступном удалённом репозитории, поэтому теперь *ваш* код базируется на *устаревшей* версии проекта и более не уместен.",
            "",
            "В этом случае использование команды `git push` является сомнительным. Как поведёт себя команда `git push`, если вы её выполните? Может быть, она изменит удалённый репозиторий и вернёт всё к тому состоянию, которое было в понедельник? А может, команда попробует добавить ваш код, не удаляя при этом новый? Или же она проигнорирует ваши изменения, так как они уже устарели?",
            "",
            "По причине того, что в данной ситуации (когда история расходится) слишком много двусмысленностей и неопределённостей, git не даст вам закачать (`push`) ваши изменения. Он будет принуждать вас включить в состав своей работы все те последние наработки и изменения, которые находятся на удалённом репозитории."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Слишком много болтовни! Давайте посмотрим, как всё работает на живом примере"
          ],
          "afterMarkdowns": [
            "Видите? Ничего не произошло. Всё потому, что команда `git push` не выполнилась успешно. Дело в том, что ваш последний коммит `C3` основан на удалённом коммите `C1`. В свою очередь, удалённый репозиторий уже изменился под воздействием `C2`. Вот почему git отклонил ваш push."
          ],
          "command": "git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Как же разрешить данную ситуацию? Всё очень просто! Всё, что вам нужно - перебазировать свою работу на самую последнюю версию удалённой ветки.",
            "",
            "Существует множество способов сделать это, но наиболее простой способ 'сдвинуть' свои наработки - через перебазировку или rebasing. Давайте посмотрим, как это выглядит."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Теперь, когда мы сперва перебазируемся прежде чем публиковать изменения..."
          ],
          "afterMarkdowns": [
            "Опа! Мы только что обновили наш локальный образ удалённого репозитория средствами `git fetch`. Ещё мы перебазировали наши наработки, чтобы они отражали все изменения с удалённого репозитория, и опубликовали их с помощью `git push`"
          ],
          "command": "git fetch; git rebase o/master; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "А есть ещё какие-либо варианты обновить мои наработки к тому моменту, как удалённый репозиторий был обновлён? Конечно есть! Давайте ознакомимся с парочкой новых штучек, но в этот раз с помощью команды `merge`.",
            "",
            "Несмотря на то, что `git merge` не передвигает ваши наработки (а всего лишь создаёт новый коммит, в котором Ваши и удалённые изменения объединены), этот способ помогает указать git-у на то, что вы собираетесь включить в состав ваших наработок все изменения с удалённого репозитория. Это значит, что ваш коммит отразится на всех коммитах удалённой ветки, поскольку удалённая ветка является *предком* вашей собственной локальной ветки.",
            "",
            "Давайте взглянем на демонстрацию..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Таким образом, если мы объединим (merge) вместо перебазирования (rebase)..."
          ],
          "afterMarkdowns": [
            "Опа! Мы обновили наше локальное представление удалённого репозитория с помощью `git fetch`, *объединили* ваши новые наработки с нашими наработками (чтобы отразить изменения в удалённом репозитории) и затем опубликовали их с помощью `git push`"
          ],
          "command": "git fetch; git merge o/master; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Здорово! А можно ли как-то сделать всё то же самое, но с меньшим количеством команд?",
            "",
            "Конечно - ведь вы уже знаете команду `git pull`, которая является аналогом и более кратким аналогом для совместных fetch и merge. А команда `git pull --rebase` - аналог для совместно вызванных fetch и rebase!",
            "",
            "Давайте взглянем на эти оба варианта."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Сперва - с флагом `--rebase`..."
          ],
          "afterMarkdowns": [
            "Тот же результат, как и ранее, но намного короче вызов команд."
          ],
          "command": "git pull --rebase; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А теперь с обычным `pull`"
          ],
          "afterMarkdowns": [
            "И снова - результат такой же, как и ранее!"
          ],
          "command": "git pull; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Рабочий процесс получения изменений (fetching), перебазирования/объединения (rebase/merging) и публикации изменений (pushing) используется довольно часто. В последующих уроках мы изучим более сложные варианты этих рабочих процессов, но пока что давайте остановимся на том, что есть.",
            "",
            "Чтобы выполнить задание уровня, сделайте следующее:",
            "",
            "* Склонируйте репозиторий",
            "* Сфабрикуйте командную работу (1 коммит)",
            "* Сделайте свой собственный коммит (1 коммит)",
            "* Опубликуйте свои наработки посредством *перебазировки (rebasing)*"
          ]
        }
      }
    ]
  },
  "merge-many-features-name": "Слияние с удалённым репозиторием",
  "merge-many-features-hint": "Внимательно посмотрите на цель уровня!",
  "merge-many-features-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Merge? Нет, нет, спасибо.",
            "",
            "Чтобы закачать (push) новые изменения в удалённый репозиторий, всё, что вам нужно сделать - это *смешать* последние изменения из удалённого репозитория. Это значит, что вы можете выполнить rebase *или* merge на удалённом репозитории (например, `o/master`).",
            "",
            "Если мы можем воспользоваться одним из двух методов, то почему же эти упражнения сфокусированы в основном на rebase? К чему такая нелюбовь к `merge`, когда речь идёт о работе с удалёнными репозиториями?",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "В среде разработчиков существует огромное количество дебатов около merging и rebasing. Ниже приведены основные за / против метода rebasing:",
            "",
            "За:",
            "",
            "* Rebasing делает дерево коммитов более чистым и читабельным, потому что всё представляется единой прямой линией.",
            "",
            "Против:",
            "",
            "* Метод rebasing явно изменяет историю коммитов в дереве.",
            "",
            "Например, коммит `C1` может быть перебазирован *после* `C3`. Соответственно, в дереве работа над `C1'` будет отображаться как идущая после `C3`, хотя на самом деле она была выполнена раньше.",
            "",
            "Некоторые разработчики любят сохранять историю и предпочитают слияние (merging). Другие (такие как я) предпочитают иметь чистое дерево коммитов, и пользуются перебазировкой (rebasing). Всё зависит от ваших предпочтений и вкусов :D"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы пройти этот уровень, решите предыдущие задачи, но с помощью *слияния (merging)*. Может быть, получится слегка неказисто, однако такое упражнение хорошо отразит суть различий."
          ]
        }
      }
    ]
  },
  "pull-name": "Git pull",
  "pull-hint": "Запустите комманду git pull !",
  "pull-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Pull",
            "",
            "Теперь, когда мы познакомились с тем, как извлекать данные из удалённого репозитория с помощью `git fetch`, давайте обновим нашу работу, чтобы отобразить все эти изменения!",
            "",
            "Существует множество вариантов решений - как только у вас имеется локальный коммит, вы можете соединить его с другой веткой. Это значит, вы можете выполнить одну из команд:",
            "",
            "* `git cherry-pick o/master`",
            "* `git rebase o/master`",
            "* `git merge o/master`",
            "* и т.д.",
            "",
            "Процедура *скачивания (fetching)*  изменений с удалённой ветки и *объединения (merging)* настолько частая и распространённая, что git предоставляет вместо двух команд - одну! Эта команда  - `git pull`."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте рассмотрим, как `fetch` и `merge` выполняются последовательно"
          ],
          "afterMarkdowns": [
            "Опа - мы скачали `C3` с помощью команды `fetch` и затем объединяем эти наработки с помощью `git merge o/master`. Теперь наша ветка `master` отображает изменения с удалённого репозитория (в данном случае — с репозитория `origin`)"
          ],
          "command": "git fetch; git merge o/master",
          "beforeCommand": "git clone; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Что же произойдёт, если вместо этих команд мы воспользуемся `git pull`?"
          ],
          "afterMarkdowns": [
            "Абсолютно то же самое! Нужно чётко понимать, что `git pull` существенно уменьшает вашу рутинную работу, если бы вы использовали `git fetch` и последующее слияние (merging) скаченной ветки."
          ],
          "command": "git pull",
          "beforeCommand": "git clone; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Мы изучим детали команды `git pull` чуть позже (включая опции и аргументы вызова команды), а пока что давайте просто попробуем эту команду.",
            "",
            "Помните, вы также можете выполнить этот уровень с помощью команд `fetch` и `merge`, но нужно ли делать так, когда можно воспользоваться всего лишь одной командой ? :P"
          ]
        }
      }
    ]
  },
  "pull-args-name": "Аргументы для pull",
  "pull-args-hint": "Напоминаю, что новые ветки можно создавать и с помощью команд fetch/pull",
  "pull-args-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Аргументы для pull",
            "",
            "Аргументы для `git pull` не покажутся вам чем-то новым, учитывая, что вы уже знакомы с аргументами для `git fetch` и `git push` :)",
            "",
            "Как мы помним, `git pull` сначала выполняет `git fetch`, а следом сразу `git merge` с той веткой, в которую притянулись обновления командой fetch. Другими словами, это все равно, что выполнить git fetch с теми же аргументами, которые вы указали для pull, а затем выполнить git merge с веткой, указанной в аргументе <приемник> команды pull.",
            "",
            "Рассмотрим на примерах:"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Вот примеры абсолютно эквивалентных команд в git:",
            "",
            "`git pull  origin foo` это то же самое, что сделать:",
            "",
            "`git fetch origin foo; git merge o/foo`",
            "",
            "И еще...",
            "",
            "`git pull  origin bar~1:bugFix` то же, что:",
            "",
            "`git fetch origin bar~1:bugFix; git merge bugFix`",
            "",
            "Как видно, git pull используется, чтобы за одну команду выполнить fetch + merge.",
            "",
            "Посмотрим демонстрацию:"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Здесь сначала выполнится fetch с аргументом указанным к pull, а merge выполняется с теми изменениями, которые будут скачаны командой fetch"
          ],
          "afterMarkdowns": [
            "Как видно, мы указали `master`, поэтому как обычно все обновления притянулись на ветку `o/master`. Затем мы слили (merge) обновленную ветку `o/master` с веткой, на которой мы находимся."
          ],
          "command": "git pull origin master",
          "beforeCommand": "git clone; go -b bar; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Будет ли это работать, если указать `<источник>` и `<приемник>`? Проверим:"
          ],
          "afterMarkdowns": [
            "Ого, сколько всего выполнено всего одной командой!. Мы создали новую ветку `foo` в локальном репозитории, скачали на неё изменения с ветки `master` удаленного репозитория, а затем слили эту ветку с веткой `bar`, на которой мы находились!"
          ],
          "command": "git pull origin master:foo",
          "beforeCommand": "git clone; git fakeTeamwork; go -b bar; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "В последнем упражнении необходимо привести дерево к аналогичному в примере. Нужно скачать несколько изменений, создать несколько новых веток, слить одни ветки в другие, но постарайтесь использовать как можно меньше команд. Удачи! :P"
          ]
        }
      }
    ]
  },
  "push-name": "Git push",
  "push-hint": "Помните, что прежде чем push-ить вам нужно склонировать репозиторий!",
  "push-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Push",
            "",
            "Хорошо, мы скачали изменения с удалённого репозитория и включили их в наши локальные наработки. Всё это замечательно, но как нам поделиться _своими_ наработками и изменениями с другими участниками проекта?",
            "",
            "Способ, которым мы воспользуемся, является противоположным тому способу, которым мы пользовались ранее для скачивания наработок (`git pull`). Этот способ - использование команды `git push`!",
            "",
            "Команда `git push` отвечает за загрузку _ваших_ изменений в указанный удалённый репозиторий, а также включение ваших коммитов в состав удалённого репозитория. По окончании работы команды `git push` все ваши друзья смогут скачать себе все сделанные вами наработки.",
            "",
            "Вы можете рассматривать команду `git push` как \"публикацию\" своей работы. Эта команда скрывает в себе множество тонкостей и нюансов, с которыми мы познакомимся в ближайшее время, а пока что давайте начнём с малого...",
            "",
            "*замечание - поведение команды `git push` без аргументов варьируется в зависимости от значения `push.default`, указанной в настройках git-а. Значение по умолчанию зависит от версии git, которую вы используете, однако в наших уроках мы будем использовать значение `upstream`. Лучше всегда проверять эту опцию прежде чем push-ить ваши настоящие проекты.*"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Здесь у нас имеются изменения, которых нет в удалённом репозитории. Давайте же закачаем их туда!"
          ],
          "afterMarkdowns": [
            "Вот так - удалённый репозиторий получил новый коммит `C2`, ветка `master` на удалённом репозитории теперь указывает на `C2`, и наше *собственное* локальное отображение удалённого репозитория (`o/master`) изменилось соответственно. Всё синхронизировалось!"
          ],
          "command": "git push",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чтобы выполнить задачу этого упражнения, просто поделитесь своими двумя новыми коммитами с удалённым репозиторием. Соберитесь, потому что все последующие уроки будут намного сложнее предыдущих!"
          ]
        }
      }
    ]
  },
  "push-args-name": "Аргументы git push",
  "push-args-hint": "Вы всегда можете ознакомиться с последним слайдом, воспользовавшись \"objective\".",
  "push-args-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Аргументы команды Push",
            "",
            "Отлично! Теперь, когда вы знаете, как следить за удалёнными ветками, мы можем начать изучение того, что скрыто под занавесом работы команд git push, fetch и pull. Мы будем рассматривать одну команду за другой, однако принципы у них очень схожи.",
            "",
            "Сперва взглянем на `git push`. В уроке, посвящённом слежению за удалённым репозиторием, вы узнали о том, что git находит удалённый репозиторий *и* ветку, в которую необходимо push-ить, благодаря свойствам текущей ветки, на которой мы находимся. Это так называемое поведение без аргументов, однако команда git push может быть также использована и с аргументами. Вид команды в данном случае:",
            "",
            "`git push <удалённый_репозиторий> <целевая_ветка>`",
            "",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Что за такой параметр `<целевая_ветка>`? Мы узнаем об этом через секунду, а пока что рассмотрим пример. Допустим, что мы выполняем такую команду:",
            "",
            "`git push origin master`",
            "",
            "дословный перевод с английского будет таким:",
            "",
            "*Перейди в ветку с именем \"master\" в моём локальном репозитории, возьми все коммиты и затем перейди на ветку \"master\" на удалённом репозитории \"origin.\". На эту удалённую ветку скопируй все отсутствующие коммиты, которые есть у меня, и скажи, когда ты закончишь.*",
            "",
            "Указывая `master` в качестве аргумента \"целевая_ветка\", мы тем самым говорим git-у откуда будут *приходить* и *уходить* наши коммиты. Аргумент \"целевая_ветка\" или \"местонахождение\" - это синхронизация между двумя репозиториями.",
            "",
            "Имейте в виду, что с тех пор, как мы сказали git-у всё, что ему необходимо (указав оба аргумента), ему - git-у - абсолютно всё равно, что вы зачекаутили до этого!"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте взглянем на пример, в котором указаны оба этих аргумента. Обратите внимание на местоположение, в котором мы находимся после чекаута."
          ],
          "afterMarkdowns": [
            "Вот так! Мы обновили `master` на удалённом репозитории, принудительно указав аргументы в push."
          ],
          "command": "git checkout C0; git push origin master",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А что бы было, ели бы мы не указывали эти аргументы, при этом используя тот же алгоритм?"
          ],
          "afterMarkdowns": [
            "Как вы видите, команда не выполнилась, так как `HEAD` потерялся и не находится на удалённо-отслеживаемой ветке."
          ],
          "command": "git checkout C0; git push",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Хорошо, для выполнения этого уровня давайте обновим обе ветки `foo` и `master` на удалённом репозитории. Фишка в том, что команда `git checkout` не доступна на этом уровне!",
            "",
            "*Замечание: Удалённые ветки помечены как `o/`, а не `origin/`. Дело в том, что полная метка не помещается на экране. Не волнуйтесь ",
            "по этому поводу... просто используйте знакомый нам `origin` для обращения к удалённому репозиторию.*"
          ]
        }
      }
    ]
  },
  "push-args2-name": "Аргументы для push -- расширенная версия!",
  "push-args2-hint": "Помните, Вы всегда можете признать своё поражение, набрав команду \"show solution\" (показать решение) :P",
  "push-args2-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Подробности аргумента `<пункт назначения>`",
            "",
            "Помните, когда в прошлом занятии мы указали в качестве аргумента ветку `master` для команды git push, мы указали совместно *источник*, откуда будут приходить коммиты, и *пункт назначения (получатель)*, куда коммиты будут уходить.",
            "",
            "Однако, вы, наверное, задаётесь вопросом - а что, если я хочу, чтобы мои источник и получатель коммитов были различными? Что, если мы хотим запушить коммиты из локальной ветки `foo` в ветку `bar` на удалённом репозитории?",
            "",
            "К огромному сожалению, это невозможно сделать средствами git... Да ладно! Я пошутил! Конечно, это возможно :)... git сам по себе достаточно гибок (даже слишком).",
            "",
            "Мы увидим, как именно, на следующем слайде..."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "В том случае, когда вам необходимо разделить источник и получатель аргумента `<пункт назначения>`, соедините их вместе, используя двоеточие:",
            "",
            "`git push origin <источник>:<получатель>`",
            "",
            "Обычно это называется `refspec`. Refspec — это всего лишь модное имя для определения местоположения, которое git может распознать (например, ветка `foo` или просто `HEAD~1`)",
            "",
            "Как только вы указали источник и получатель независимо друг от друга, вы можете довольно причудливо и точно использовать команды для работы с удалёнными ветками и репозиториями. Давайте взглянем на демонстрацию!"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Помните, `источник` - всего лишь местоположение, которое git должен понять:"
          ],
          "afterMarkdowns": [
            "Вау! Это довольно нетривиальная команда, однако она имеет смысл - git видит в `foo^` не что иное, как местоположение, закачивает все коммиты, которые не присутствуют на удалённом репозитории, и затем обновляет получателя."
          ],
          "command": "git push origin foo^:master",
          "beforeCommand": "git clone; go -b foo; git commit; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А что если пункт назначения, в который вы хотите запушить, не существует? Без проблем! Укажите имя ветки, и git сам создаст ветку на удалённом репозитории для вас."
          ],
          "afterMarkdowns": [
            "Класс! Довольно легко! :D"
          ],
          "command": "git push origin master:newBranch",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Для выполнения данного уровня попытайтесь привести своё дерево к такому же виду, как на визуализации. И не забудьте о формате:",
            "",
            "`<источник>:<получатель>`"
          ]
        }
      }
    ]
  },
  "push-many-features-name": "Push Мастер!",
  "push-many-features-hint": "Помни - ты всегда можешь отменить команды с помощью undo или reset",
  "push-many-features-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Слияние фича-бранчей (веток)",
            "",
            "Теперь, когда вы умело владеете командами fetch, pull и push, давайте применим эти навыки в сочетании с новым рабочим процессом (он же workflow).",
            "",
            "Среди разработчиков, вовлечённых в большой проект, довольно распространённ приём — выполнять всю свою работу в так называемых фича-бранчах (вне `master`). А затем, как только работа выполнена, разработчик интегрирует всё, что было им сделано. Всё это, за исключением одного шага, похоже на предыдущий урок (там, где мы закачивали ветки на удалённый репозиторий)",
            "",
            "Ряд разработчиков делают push и pull лишь на локальную ветку `master` - таким образом ветка `master` всегда синхронизирована с тем, что находится на удалённом репозитории (`o/master`).",
            "",
            "Для этого рабочего процесса мы совместили две вещи:",
            "",
            "* интеграцию фича-бранчей в `master`",
            "* закачку (push) и скачку (pull) с удалённого репозитория"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте быстренько вспомним, как нам обновить `master` и закачать выполненную работу."
          ],
          "afterMarkdowns": [
            "Здесь мы выполнили две команды, которые:",
            "",
            "* перебазировали нашу работу на новенький коммит, пришедший с удалённого репозитория, и",
            "* закачали свои наработки в удалённый репозиторий"
          ],
          "command": "git pull --rebase; git push",
          "beforeCommand": "git clone; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Текущая задача является достаточно обильной - здесь представлена общая схема выполнения:",
            "",
            "* Есть три фича-бранчи (фича-ветки) - `side1` `side2` и `side3`",
            "* Нам необходимо закачать каждую из них по очереди на удалённый репозиторий",
            "* При этом удалённый репозиторий хранит в себе какие-то наработки, которые также следует скачать к себе",
            "",
            ":O Сложно! Желаю вам удачи в выполнении этой непростой задачи."
          ]
        }
      }
    ]
  },
  "remote-branches-name": "Удалённые ветки",
  "remote-branches-hint": "Уделяйте внимание очерёдности -- сперва commit на master",
  "remote-branches-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Удалённые ветки в Git",
            "",
            "Теперь, когда вы уже увидели `git clone` в действии, давайте углубимся в детали и посмотрим что же на самом деле изменилось.",
            "",
            "Во-первых, вы должны были заметить, что у нас в локальном репозитории появилась новая ветка с именем `o/master`. Такой тип ветки называется _удалённой_ веткой. Поскольку удалённые ветки играют важную и уникальную роль, они обладают рядом специальных свойств.",
            "",
            "Удалённые ветки отражают _состояние_ удалённых репозиториев (с того момента, как вы обращались к этим удалённым репозиториям в последний раз). Они позволяют вам отслеживать и видеть разницу между вашими локальными наработками и тем, что было сделано другими участниками - важный шаг, который необходимо делать, прежде чем делиться своими наработками с другими.",
            "",
            "Важным свойством удалённых веток является тот факт, что когда вы извлекаете их, вы отделяете (detaching) `HEAD`. Git делает это потому, что вы не можете работать непосредственно в этих ветках; сперва вам необходимо сделать наработки где-либо, а уж затем делиться ими с удалёнными репозиториями (после чего ваши удалённые ветки будут обновлены)."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Что такое `o/` в названии ветки?",
            "",
            "Вы, наверное, догадались, что первый символ `o/` в названии ветки служит для обозначения именно удалённых веток. Да. Удалённые ветки также имеют (обязательное) правило именования - они отображаются в формате:",
            "",
            "* `<удалённый репозиторий>/<имя ветки>`",
            "",
            "Следовательно, если вы взглянете на имя ветки `o/master`, то здесь `master` - это имя ветки, а `o` - это имя удалённого репозитория.",
            "",
            "Большинство разработчиков именуют свои главные удалённые репозитории не как `o`, а как `origin`. Также общепринятым является именование удалённого репозитория как `origin`, когда вы клонируете репозиторий командой `git clone`.",
            "",
            "К сожалению, полное имя `origin` не помещается на элементах дизайна наших уроков, поэтому мы используем краткое `o` :( Просто помните, когда вы пользуетесь git в реальном проекте, ваш удалённый репозиторий скорее всего будет называться `origin`!",
            "",
            "Давайте посмотрим на всё это в действии."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте извлечём (check out) удалённую ветку и посмотрим что произойдёт"
          ],
          "afterMarkdowns": [
            "Как вы можете видеть, git отделил (detached) `HEAD` и не обновил `o/master`, когда мы добавили новый коммит. Всё потому, что `o/master` обновится тогда и только тогда, когда обновится сам удалённый репозиторий."
          ],
          "command": "git checkout o/master; git commit",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Для завершения уровня выполните коммит единожды на `master`, а затем на `o/master` (предварительно переключившись на эту ветку). Это наглядно продемонстрирует поведение удалённых веток, а также покажет, как изменения влияют на состояние удалённых репозиториев."
          ]
        }
      }
    ]
  },
  "source-nothing-name": "Пустой источник",
  "source-nothing-hint": "Команда branch недоступна на этом упражнении, пользуйтесь командой fetch!",
  "source-nothing-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Странный `<источник>`",
            "",
            "Git использует параметр `<источник>` странным образом. Странность заключается в том, что Вы можете оставить пустым параметр `<источник>` для команд git push и git fetch:",
            "",
            "* `git push origin :side`",
            "* `git fetch origin :bugFix`",
            "",
            "Посмотрим, что же из этого выйдет..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Что же будет с веткой, на которую мы делаем git push с пустым аргументом `<источник>`? Она будет удалена!"
          ],
          "afterMarkdowns": [
            "Как видите, мы удалили ветку `foo` в удаленном репозитории, попытавшить протолкнуть(git push) в неё \"ничего\"."
          ],
          "command": "git push origin :foo",
          "beforeCommand": "git clone; git push origin master:foo"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Наконец, если мы попытаемся притянуть изменения(git fetch) из \"ничего\" к нам в локальный репозиторий, то это создаст у нас новую ветку"
          ],
          "afterMarkdowns": [
            "Вот такой вот чудной git!"
          ],
          "command": "git fetch origin :bar",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Это легкое упражнение - нужно всего лишь удалить одну ветку в удаленном репозитории и создать новую ветку в локальном, с помощью команд `git push` и `git fetch` соответственно!"
          ]
        }
      }
    ]
  },
  "tracking-name": "Слежка за удалённым репозиторием",
  "tracking-hint": "Помни, есть два способа установить слежку за удалённым репозиторием!",
  "tracking-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Удалённые-отслеживаемые ветки",
            "",
            "Единственное, что могло бы показаться вам \"магией\" в нескольких предыдущих уроках - это то, как git знает, что ветка `master` соответствует `o/master`. Конечно, эти ветки имеют схожие имена и связь между локальной и удалённой ветками `master` выглядит вполне логично, однако, эта связь наглядно продемонстрирована в двух сценариях:",
            "",
            "* Во время операции pull коммиты скачиваются в ветку `o/master` и затем *соединяются* в ветку `master`. Подразумеваемая цель слияния определяется исходя из этой связи.",
            "* Во время операции push наработки из ветки `master` закачиваются на удалённую ветку `master` (которая в локальном представлении выглядит как `o/master`). *Пункт назначения* операции push определяется исходя из связи между `master` и `o/master`.",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Удалённые-отслеживаемые ветки",
            "",
            "Короче, связь между `master` и `o/master` объясняется не иначе как свойство \"удалённое отслеживание\" веток. Ветка `master` настроена так, чтобы следить за `o/master` -- это подразумевает наличие источника для merge и пункта назначения для push в контексте ветки `master`.",
            "",
            "Вы, должно быть, удивлены, как это отслеживание появилось на ветке `master`, если мы не запускали ни одной специфической команды. На самом деле, когда вы клонируете репозиторий, это слежение включается автоматически.",
            "",
            "В процессе клонирования git локально создаёт удалённые ветки для каждой ветки с удалённого репозитория (такие как `o/master`). Затем он - git - создаёт локальные ветки, которые отслеживают текущую, активную ветку на удалённом репозитории. В большинстве случаев - это `master`.",
            "",
            "К тому моменту как `git clone` завершит своё выполнение, у вас будет лишь одна локальная ветка (так что вы ещё не сильно перегружены), но, если вам будет интересно, вы сможете увидеть все удалённые ветки (при желании).",
            "",
            "Именно это объясняет, почему сразу после клонирования вы видите в консоли надпись:",
            "",
            "    local branch \"master\" set to track remote branch \"o/master\"",
            "",
            "    (локальная ветка \"master\" теперь следит за удалённой веткой \"o/master\") "
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### А могу ли я сделать это самостоятельно?",
            "",
            "Само собой! Вы можете сказать любой из веток, чтобы она отслеживала `o/master`, и если вы так сделаете, эта ветка будет иметь такой же пункт назначения для push и merge как и локальная ветка `master`. Это значит, что вы можете выполнить `git push`, находясь на ветке `totallyNotMaster`, и все ваши наработки с ветки `totallyNotMaster` будут закачены на ветку `master` удалённого репозитория!",
            "",
            "Есть два способа сделать это. Первый - это выполнить checkout для новой ветки, указав удалённую ветку в качестве ссылки. Для этого необходимо выполнить команду",
            "",
            "`git checkout -b totallyNotMaster o/master`",
            "",
            ", которая создаст новую ветку с именем `totallyNotMaster` и укажет ей следить за `o/master`."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Хватит болтовни, давайте взглянем на демонстрацию! Мы выполним checkout для новой ветки `foo` и укажем ей, чтобы она отслеживала `master` с удалённого репозитория."
          ],
          "afterMarkdowns": [
            "Как вы увидели, мы использовали `o/master`, чтобы обновить ветку `foo`. Обратите внимание, как обновился `master`!!"
          ],
          "command": "git checkout -b foo o/master; git pull",
          "beforeCommand": "git clone; git fakeTeamwork"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Это работает также и для git push"
          ],
          "afterMarkdowns": [
            "Оп! Мы закачали наши наработки на ветку `master` нашего удалённого репозитория. При том, что наша локальная ветка называется абсолютно по-другому."
          ],
          "command": "git checkout -b foo o/master; git commit; git push",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Способ №2",
            "",
            "Другой способ указать ветке отслеживать удалённую ветку — это просто использовать команду `git branch -u`. Выполнив команду",
            "",
            "`git branch -u o/master foo`",
            "",
            "вы укажете ветке `foo` следить за `o/master`. А если вы ещё при этом находитесь на ветке `foo`, то её можно не указывать:",
            "",
            "`git branch -u o/master`",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Как видно, второй способ указать слежение за веткой намного быстрее..."
          ],
          "afterMarkdowns": [
            "Словом, всё как и раньше, просто отдельная, специальная команда. Здорово!"
          ],
          "command": "git branch -u o/master foo; git commit; git push",
          "beforeCommand": "git clone; git checkout -b foo"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Отлично! Для выполнения этого уровня давайте выполним push наших наработок в ветку `master` на удалённом репозитории, при этом *не* скачивая и не создавая ветку `master` локально. Я объясню вам оставшееся чуть позже, т.к. это продвинутый курс :P"
          ]
        }
      }
    ]
  },
  "sequence-intro-display": "Введение",
  "sequence-intro-about": "Хорошо подобранное введение в основные команды git",
  "sequence-rampup-display": "Едем дальше",
  "sequence-rampup-about": "Следующая порция абсолютной git-крутотенюшки. Проголодались?",
  "sequence-remote-display": "Push & Pull - удалённые репозитории в Git!",
  "sequence-remote-about": "Настало время поделиться своими единичками и нулями. Время коллективного программирования",
  "sequence-remote-advanced-display": "Через origin – к звёздам. Продвинутое использование Git Remotes",
  "sequence-remote-advanced-about": "Весело было быть всесильным мудрым правителем...",
  "sequence-move-display": "Перемещаем труды туда-сюда",
  "sequence-move-about": "Не стесняйтесь менять историю",
  "sequence-mixed-display": "Сборная солянка",
  "sequence-mixed-about": "Ассорти из приёмов работы с Git, хитростей и советов",
  "sequence-advanced-display": "Продвинутый уровень",
  "sequence-advanced-about": "Если ты смелый, ловкий, умелый – потренируйся тут",
  "dialogs-confirm": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Уверен, что хочешь посмотреть решение?",
          "",
          "Мы верим в тебя! Не прыгай! Ты сможешь!"
        ]
      }
    }
  ],
  "dialogs-level-builder": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Добро пожаловать в конструктор уровней!",
          "",
          "Вот основные шаги:",
          "",
          "  * Настроить стартовое дерево при помощи команд git",
          "  * Обозначить старовое дерево при помощи ```define start```",
          "  * Ввести команды \"оптимального\" решения уровня",
          "  * Обозначить цель уровня при помощи ```define goal```. Одновременно обозначится решение.",
          "  * По желанию, можно указать подсказку при помощи ```define hint```",
          "  * Указать название уровня при помощи ```define name```",
          "  * По желанию, указать стартовое сообщение при помощи ```edit dialog```",
          "  * Ввести ```finish``` и получить JSON с описанием уровня!"
        ]
      }
    }
  ],
  "dialogs-next-level": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Супер!",
          "",
          "Ты прошёл уровень. Количество использованных команд - *{numCommands}* ; ",
          "а наше решение состоит из {best}."
        ]
      }
    }
  ],
  "dialogs-sandbox": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Добро пожаловать в LearnGitBranching!",
          "",
          "Это приложение создано, чтобы помочь новичкам постичь ",
          "мощные возможности ветвления и работы ",
          "с git. Мы надеемся, что вам понравится эта игра ",
          "и может вы что-то усвоите!",
          "",
          "# Демо!",
          "",
          "Если ты не видел демонстрацию – посмотри её тут:",
          "",
          "[https://pcottle.github.io/learnGitBranching/?demo](https://pcottle.github.io/learnGitBranching/?demo)",
          "",
          "Достало это сообщение? Добавь `?NODEMO` к адресу и навсегда забудь о нём, ниже ссылка для удобства:",
          "",
          "[https://pcottle.github.io/learnGitBranching/?NODEMO](?NODEMO)"
        ]
      }
    },
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Команды Git",
          "",
          "В нашей песочнице можно использовать множество команд:",
          "",
          " * commit",
          " * branch",
          " * checkout",
          " * cherry-pick",
          " * reset",
          " * revert",
          " * rebase",
          " * merge"
        ]
      }
    },
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Бог велел – делись!",
          "",
          "Ты можешь делиться результатами с друзьями при помощи `export tree` и `import tree`",
          "",
          "Хочешь создать классный уровень? Сделай это при помощи `build level` или добавь уровень друга при помощи `import level`",
          "",
          "Команда `show commands` покажет все доступные инструкции. Там есть очень полезные, например `undo` и `reset`",
          "",
          "А пока просто начни игру при помощи `levels`..."
        ]
      }
    }
  ],
  "finish-dialog-finished": "Вау! Вы прошли последний уровень, отлично!",
  "finish-dialog-next": "Хотите перейти на следующий уровень: *\"{nextLevel}\"*?",
  "finish-dialog-win": "Отлично! Ваше решение соответствует или превосходит наше.",
  "finish-dialog-lose": "Попробуйте, может вы сможете уложиться в {best} : D",
  "hg-prune-tree": "Внимание! Mercurial использует агрессивный сборщик мусора и обрезает ваше дерево",
  "hg-a-option": "Опция -A не требуется для этого приложения, просто сделайте коммит.",
  "hg-error-no-status": "Команда status не поддерживается в этом приложении, так как здесь нет файлов. Попробуйте выполнить hg summary",
  "hg-error-need-option": "Для этой команды требуется опция {option}",
  "hg-error-log-no-follow": "hg log без опции -f в настоящий момент не поддерживается, используйте -f",
  "git-status-detached": "Отделенный HEAD",
  "git-status-onbranch": "В ветке {branch}",
  "git-status-readytocommit": "Готово к коммиту! (как и всегда в этом демо)",
  "git-dummy-msg": "Быстрый коммит. А надо!",
  "git-error-origin-fetch-uptodate": "Уже обновлено!",
  "git-error-origin-fetch-no-ff": "Ваша origin ветка не синхронизирована с удаленной веткой, невозможно выполнить fetch",
  "git-error-origin-push-no-ff": "Удаленный репозиторий разошелся с вашим локальным репозиторием, поэтому выгрузка ваших изменений не может быть в режиме fast forward (и следовательно ваш push будет отклонён). Пожалуйста, удалите изменения в удаленном репозитории которые, объедините их в эту ветку и попробуйте еще раз. Вы можете сделать это с помощью git pull или git pull --rebase",
  "git-error-remote-branch": "Вы не можете выполнить эту команду на удаленной ветке",
  "git-error-origin-required": "Origin требуется для этой команды",
  "git-error-origin-exists": "Origin уже существует! Невозможно создать еще один",
  "git-error-branch": "Невозможно удалить ветку master, ветку на которой вы сейчас и то что не является веткой",
  "git-merge-msg": "Слияние {target} в {current}",
  "git-error-rebase-none": "Нет коммитов для rebase! Все в коммите слияния или изменения уже применены",
  "git-result-nothing": "Нечего выполнять...",
  "git-result-fastforward": "Выполняю Fast forward...",
  "git-result-uptodate": "Ветка уже обновлена",
  "git-error-exist": "Ссылка {ref} не существует или неизвестна",
  "git-error-relative-ref": "Коммит {commit} не содержит {match}",
  "git-warning-detached": "Внимание! Репозиторий в состоянии detached HEAD, то есть не находится ни на какой ветке!",
  "git-warning-add": "Это демо не оперирует файлами",
  "git-error-options": "Неправильные опции",
  "git-error-already-exists": "Коммит {commit} существует, отменяю!",
  "git-error-reset-detached": "Это невозможно в режиме detached HEAD! Используйте checkout!",
  "git-warning-hard": "По умолчанию будет выполнен --hard reset, эту опцию можно опускать!",
  "git-error-staging": "Это демо не работает с файлами, так что git add не нужен!",
  "git-revert-msg": "Откатываю {oldCommit}: {oldMsg}",
  "git-error-args-many": "Ожидается максимум {upper} аргумент(ов) для {what}",
  "git-error-args-few": "Ожидается как минимум {lower} аргументов для {what}",
  "git-error-no-general-args": "Это команда без аргументов",
  "copy-tree-string": "Скопируй текст ниже",
  "learn-git-branching": "Изучаем ветвление в git",
  "select-a-level": "Выбери уровень",
  "main-levels-tab": "Основы",
  "remote-levels-tab": "Удаленные репозитории",
  "branch-name-short": "Для наглядности нам нужно сохранять имена веток короткими. Твоё название сокращено до 9 символов и теперь это \"{branch}\"",
  "bad-branch-name": "Название для ветки \"{branch}\" недопустимо!",
  "bad-tag-name": "Название для тега \"{tag}\" недопустимо!",
  "option-not-supported": "Опция \"{option}\" недопустима!",
  "git-usage-command": "git <команда> [<аргументы>]",
  "git-supported-commands": "Поддерживаемые команды",
  "git-usage": "Использование:",
  "git-version": "Версия git PCOTTLE.1.0",
  "flip-tree-command": "Переворачиваю дерево...",
  "refresh-tree-command": "Обновляю дерево...",
  "locale-command": "Локаль теперь равна {locale}",
  "locale-reset-command": "Локаль сброшена. Теперь она равна {locale}",
  "show-command": "Для получения большей информации используй следующие команды:",
  "show-all-commands": "Вот все поддерживаемуе команды:",
  "cd-command": "Директория изменена на \"/директории/не/важны/в/этом/демо\"",
  "ls-command": "НеНадоЗаботитьсяОФайлахВЭтомДемо.txt",
  "mobile-alert": "Мобильные не поддерживаются, зайди с компьютера!",
  "share-tree": "Поделись деревом с друзьями! Они могут загрузить его при помощи \"import tree\"",
  "paste-json": "Вставь JSON ниже!",
  "solved-map-reset": "Всё сброшено! Можно начать с чистого листа!",
  "level-cant-exit": "Ты не проходишь уровень! Ты в песочнице! Чтобы начать уровень, используй команду \"levels\"!",
  "level-no-id": "Уровень с id \"{id}\" не найден! Открываю выбор уровней",
  "undo-stack-empty": "Некуда откатывать!",
  "already-solved": "Ты уже прошел этот уровень, попробуй пройти другие при помощи команды \"levels\" или иди в песочницу \"sandbox\"",
  "solved-level": "Решено!!\n:D",
  "command-disabled": "На этом уровне нельзя использовать эту команду!",
  "share-json": "Вот JSON для этого уровня! Поделись им с кем-нибудь или отправь его нам на GitHub",
  "want-start-dialog": "Не указано стартово сообщение! Точно продолжаем?",
  "want-hint": "Не указана подсказка для уровня! Пренебречь? Вальсируем?",
  "prompt-hint": "Введи подсказку для уровня, если хочешь.",
  "prompt-name": "Введи название уровня",
  "solution-empty": "Решение не указано! Так не годится!",
  "define-start-warning": "Устанавливаю стартовую точку... Решение и итоговое состояние будут стёрты, если они указаны ранее",
  "help-vague-level": "При прохождении уровня доступны несколько видов помощи. Определить что нужно: \"help level\" чтобы получить информацию об этом уровне, \"help general\" для того, чтобы узнать о игре в целом или \"objective\" чтобы узнать что надо сделать в этом уровне.",
  "help-vague-builder": "При создании уровней доступны несколько видов помощи. Выбери между \"help general\" и \"help builder\"",
  "show-goal-button": "Цель уровня",
  "hide-goal-button": "Спрятать цель",
  "objective-button": "Задача",
  "git-demonstration-title": "Git демо",
  "goal-to-reach": "Цель уровня",
  "goal-only-master": "<span class=\"fwber\">Важно:</span> В этом уровне проверяется только ветка master. Остальные ветки просто для наглядности. Как обычно, можно скрыть это сообщение при помощи \"hide goal\"",
  "hide-goal": "Можно скрыть это окно при помощи \"hide goal\"",
  "hide-start": "Можно скрыть это окно при помощи \"hide start\"",
  "level-builder": "Редактор уровней",
  "no-start-dialog": "Нет стартового сообщение для уровня!",
  "no-hint": "Милый мой, хороший, догадайся сам :-/ Подсказка не создана...",
  "error-untranslated-key": "Перевода для {key} не создано :( Пожалуйста, предложи перевод на GitHub",
  "error-untranslated": "Для этого сообщения нет перевода :( Пожалуйста, предложи перевод на GitHub"
}
