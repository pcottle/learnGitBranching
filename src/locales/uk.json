{
  "multiple-parents-name": "Декілька батьків",
  "multiple-parents-hint": "Використай \"git branch bugWork\" на потрібному коміті щоб створити потрібне посилання",
  "multiple-parents-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Вибираємо Попередників",
            "",
            "Так само як і модифікатор `~`, модифікатор `^` також приймає необов’язкове число після нього.",
            "",
            "Замість того, щоб вказувати кількість генерацій щоб переміститись назад  (те що робить `~`), число після `^` вказує на яке батьківське посилання мерджу потрібно перейти. Зауважте що так як мерджевий коміт має декілька батьків, використання '^' без числа є неоднозначним.",
            "",
            "Git зазвичай перейде на \"першого\" з батьків вверх з мерджевого коміту, але вказання числа після  `^` змінює цю поведінку. ",
            "",
            "Годі ляси точити, перевірмо як це працює в дії.",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Ось ми маємо мерджевий коміт. Якщо зробимо checkout `master^` без числа, ми потрапимо на першого з предків ",
            "",
            "(*В нашій візуалізації перший предок знаходиться прямо над мерджевим комітом*)"
          ],
          "afterMarkdowns": [
            "Легко -- те до чого ми всі звикли."
          ],
          "command": "git checkout master^",
          "beforeCommand": "git checkout HEAD^; git commit; git checkout master; git merge C2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Тепер спробуймо натомість вказати другого батька..."
          ],
          "afterMarkdowns": [
            "Бачиш? Ми перейшли до другого батька вверх."
          ],
          "command": "git checkout master^2",
          "beforeCommand": "git checkout HEAD^; git commit; git checkout master; git merge C2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Модифікатори `^` та `~` дозволяють легко пересуватися деревом комітів:"
          ],
          "afterMarkdowns": [
            "Супер швидко!"
          ],
          "command": "git checkout HEAD~; git checkout HEAD^2; git checkout HEAD~2",
          "beforeCommand": "git commit; git checkout C0; git commit; git commit; git commit; git checkout master; git merge C5; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Більше того, ці модифікатори можна використовувати разом! Заціни:"
          ],
          "afterMarkdowns": [
            "Те саме, що й перед цим, але однією командою."
          ],
          "command": "git checkout HEAD~^2~2",
          "beforeCommand": "git commit; git checkout C0; git commit; git commit; git commit; git checkout master; git merge C5; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Практика",
            "",
            "Щоб завершити цей рівень, створи нову гілку на вказаному місці.",
            "",
            "Очевидно, що в данному випадку досить легко вказати коміт напряму (щось на зразок checkout `C6`), але для закріплення матеріалу використай модифікатори, про які ми щойно говорили!"
          ]
        }
      }
    ]
  },
  "branching-name": "Розгалуження в Git",
  "branching-hint": "Створи нову гілку за допомогою \"git branch [ім’я]\" й перейди на неї за допомогою \"git checkout [ім’я]\"",
  "branching-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Гілки в Git",
            "",
            "Гілки в Git також є дивовижно легкими. Вони є просто посиланнями на конкретний коміт, нічого більше. Через це багато Git-ентузіастів повторюють мантру:",
            "",
            "```",
            "роби гілки завчасно, роби гілки часто",
            "```",
            "",
            "Через те, що сворення нових гілок ніяк не впливає на використання пам’яті чи дискового простору, набагато простіше розділити свою роботу на кілька логічно зв’язаних по функціоналу гілок, ніж працювати з величезними гілками.",
            "",
            "Коли ми почнемо використовувати гілки та коміти, ми побачимо, як вони поєднуються між собою. Але зараз просто запам’ятай, що гілка просто зберігає роботу теперішнього коміту і всіх його попередників."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте на практиці подивимось, як виглядають гілки в Git.",
            "",
            "Зараз ми створимо нову гілку `newImage`."
          ],
          "afterMarkdowns": [
            "Ось і все, що треба знати про гілки. Гілка `newImage` тепер посилається на коміт `C1`."
          ],
          "command": "git branch newImage",
          "beforeCommand": ""
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте спробуємо додати якусь інформацію до цієї нової гілки. Натисни кнопку внизу."
          ],
          "afterMarkdowns": [
            "От халепа! Гілка `master` просунулася вперед, але гілка `newImage` — ні! Це тому, що ми були не \"на новій гілці\". Через це зірочка (*) була поруч з  `master`."
          ],
          "command": "git commit",
          "beforeCommand": "git branch newImage"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте вкажемо Git, що ми хочемо перейти на нову гілку за допомогою",
            "",
            "```",
            "git checkout [ім’я]",
            "```",
            "",
            "Ця команда перекине нас на нову гілку до того, як ми закомітимо наші зміни."
          ],
          "afterMarkdowns": [
            "Ось і все! Наші зміни були записані в нову гілку."
          ],
          "command": "git checkout newImage; git commit",
          "beforeCommand": "git branch newImage"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Тепер ти готовий до створення гілок. Як тільки це вікно пропаде, ",
            "зроби нову гілку з назвою `bugFix` та перейди на неї."
          ]
        }
      }
    ]
  },
  "commits-name": "Знайомство з комітами в Git",
  "commits-hint": "Спробуй двічі виконати команду 'git commit' ;)",
  "commits-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Коміти в Git",
            "Коміт в Git репозиторії зберігає моментальну копію всіх файлів в поточній директорії. Це як гігантська копіпаста, тільки краще.",
            "",
            "Git намагається зберігати коміти якнайпростіше й ефективніше, тому він не просто копіює всю директорію при кожному коміті. Він може стиснути коміт в набір правок чи \"дельту\" між двома версіями репозиторію.",
            "",
            "Git також зберігає історію коли і ким був створений той чи інший коміт. Тому більшість комітів мають комітів-предків, що знаходяться вище в ієрархії — ми це зображуємо стрілочками в нашій візуалізації. Історія — це необхідна річ для кожного, хто працює з конкретним проектом.",
            "",
            "Тут є багато над чим подумати, але наразі ти можеш уявляти коміти як моментальні знімки проекту. Коміти майже невагомі й перемикання між ними дуже швидке."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давай подивимось, як це виглядає на практиці. Справа зображена візуалізація маленького Git-репозиторію. Наразі ми бачимо два коміти: початковий коміт `C0`, та наступний коміт `C1`, який містить якісь змістовні зміни.",
            "",
            "Натисни кнопку нижче, щоб створити новий коміт."
          ],
          "afterMarkdowns": [
            "Чудово. Ми щойно зробили деякі зміни з репозиторієм і зберегли їх як новий коміт. Цей коміт має предка `C1`, який вказує на коміт, з якого він був створений."
          ],
          "command": "git commit",
          "beforeCommand": ""
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Спробуй сам. Після того як це вікно закриється, зроби два коміти, щоб пройти цей рівень."
          ]
        }
      }
    ]
  },
  "merging-name": "Злиття гілок в Git",
  "merging-hint": "Не забудь робити коміти в правильному порядку (спочатку bugFix, а вже потім master)",
  "merging-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Гілки та їх Злиття",
            "",
            "Чудово! Ми знаємо як комітити та створювати гілки. Тепер потрібно навчитися в якийсь спосіб поєднувати інфу з двох чи більше гілок. Це дозволить нам відгілкуватись, зробити нову фічу, й потім інтегрувати її назад.",
            "",
            "Перший спосіб об’єднувати робочу інфу з яким ми розберемось це `git merge`. Команда merge (злити) в Git створює спеціальний коміт який має двох унікальних батьків. Коміт з двома батьками в приниципі просто значить що в нього включена інфа з обох батьків і всіх їх попередників.",
            "",
            "Це простіше сприймається візуально, тому розберемо це в наступному слайді"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Тут ми маємо дві гілки; кожна з них містить унікальний коміт. Це означає що жодна з них не містить повного набору \"робочої інфи\" в цьому репозиторії. Давайте зіллємо всю інфу докупи за допомогою merge.",
            "",
            "Ми `змержимо` гілку `bugFix` в `master`"
          ],
          "afterMarkdowns": [
            "Нічого собі! Ви це бачили? По-перше, `master` тепер вказує на коміт з двома батьками. Якщо ти піднімешся вверх з цього коміту по дереву, починаючи з `master`, на шляху ти зустрінеш кожен коміт аж до кореневого. Це означає що гілка `master` тепер містить всю інфу в цьому репозиторії.",
            "",
            "А ти помітив як змінилися кольори комітів? Для кращого розуміння процесу я додав певну кольорову диференціацію. Кожен бранч виділено окремим кольором. Колір кожного коміту це суміш кольорів всіх гілок що місять цей коміт.",
            "",
            "Тож ми бачимо що колір гілки `master` містять всі коміти, але не колір `bugFix`. Давайте виправимо це..."
          ],
          "command": "git merge bugFix",
          "beforeCommand": "git checkout -b bugFix; git commit; git checkout master; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давай змержимо `master` в `bugFix`:"
          ],
          "afterMarkdowns": [
            "Так як `bugFix` є нащадком `master`, git'у не потрібно нічого робити; він просто пересунув `bugFix` на тей самий коміт, на якому знаходиться `master`.",
            "",
            "Тепер всі коміти одного кольору, що означає що кожен бранч включає в собі всю корисну інфу яка є в цьому репозиторії! Ура!"
          ],
          "command": "git checkout bugFix; git merge master",
          "beforeCommand": "git checkout -b bugFix; git commit; git checkout master; git commit; git merge bugFix"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень виконай наступні кроки:",
            "",
            "* Зроби нову гілку (branch) з назвою `bugFix`",
            "* Перейди на кілку `bugFix` за допомогою `git checkout bugFix`",
            "* Зроби один коміт",
            "* Повернись до `master` за допомогою `git checkout`",
            "* Зроби ще один коміт",
            "* Змерджи (злий) гілку `bugFix` в `master` за допомогою `git merge`",
            "",
            "*Не забувай, ти можеш завжди повернутися до цього діалогу за допомогою \"objective\"!*"
          ]
        }
      }
    ]
  },
  "rebasing-name": "Знайомство з rebase",
  "rebasing-hint": "Впевнись, що зробив коміт в гілці bugFix",
  "rebasing-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Rebase",
            "",
            "Інший спосіб комбінування змін з різних бранчів називається *rebase*. Rebase по суті бере кілька комітів , \"копіює\" їх, й кладе їх в інше місце.",
            "",
            "Це може звучати трохи незрозуміло, але основна перевага rebase в тому, що його використовують щоб створити зручну лінійну послідовність комітів. Коміт лог та історія будуть виглядати набагато чистіша, якщо користуватися лише rebase (а не merge)",
            "",
            "Спробуємо на практиці..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Ми знову маємо дві гілки; зауваж, що наразі вибрана гілка bugFix (вважай зірочку)",
            "",
            "Ми хочемо перемістити наші зміни з гілки bugFix прямо до змін з гілки master. Тоді це буде виглядати наче ці зміни були додані одна за одною, хоча насправді вони були додані одночасно.",
            "",
            "Давайте зробимо це за допомогою команди `git rebase`"
          ],
          "afterMarkdowns": [
            "Добре! Тепер зміни з гілки bugFix знаходяться прямо попереду змін з master й ми отримали зручну лінійну послідовність комітів.",
            "",
            "Вважай що коміт C3 досі десь існує (в дереві він тьмяніший за решту), й C3' це \"копія\" яку ми заребейсили в master.",
            "",
            "Є лише одна проблема: гілка master також не була оновлена, давайте зробимо це наступним кроком..."
          ],
          "command": "git rebase master",
          "beforeCommand": "git commit; git checkout -b bugFix C1; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Тепер ми перейшли (checkout) до гілки `master`. Далі робимо rebase на `bugFix`..."
          ],
          "afterMarkdowns": [
            "Вуаля! Так як `master` це предок `bugFix`, git просто просунув посилання гілки `master` вперед в історії."
          ],
          "command": "git rebase bugFix",
          "beforeCommand": "git commit; git checkout -b bugFix C1; git commit; git rebase master; git checkout master"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень, зроби наступне:",
            "",
            "* Зачекауть (checkout) новий бранч з назвою `bugFix`",
            "* Зроби один коміт",
            "* Повернись на master й зроби ще один коміт",
            "* Зачекауть bugFix знову й заребейсь його на master",
            "",
            "Нехай щастить!"
          ]
        }
      }
    ]
  },
  "describe-name": "Git Describe",
  "describe-hint": "Просто зроби один коміт в bugFix коли ти будеш готовий іти далі",
  "describe-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Git Describe",
            "",
            "Через те, що таги є такими чудовими \"орієнтирами\" по коду, git також має команду *описати* (describe) де ти є відносно найближчого \"орієнтира\" (тобто тага). І ця команда називається `git describe`!",
            "",
            "Git describe допоможе тобі знайти себе після того як ти перестрибнеш на кілька комітів по історії вперед чи назад; це може статися після того як ти закінчив git bisect (пошук-дебаггер) чи коли тебе попросили підійти до колеги, котрий щойно прийшов з відпустки."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Git describe має наступну форму:",
            "",
            "`git describe <посилання>`",
            "",
            "Де `<посилання>` -- це будь-що, що вказує на конкретний коміт. Якщо ти не вкажеш посилання, git використає поточну локацію (`HEAD`).",
            "",
            "Вивід команди виглядає як:",
            "",
            "`<таг>_<к-ть комітів>_g<хеш>`",
            "",
            "де `таг` -- це найближчий попередній таг з історії; `к-ть комітів` -- це наскільки далеко цей таг в історії, а `<хеш>` -- це хеш коміту, який описується."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Розгляньмо короткий приклад. Для дерева нижче:"
          ],
          "afterMarkdowns": [
            "Команда `git describe master` виведе:",
            "",
            "`v1_2_gC2`",
            "",
            "коли `git describe side` виведе:",
            "",
            "`v2_1_gC4`"
          ],
          "command": "git tag v2 C3",
          "beforeCommand": "git commit; go -b side HEAD~1; gc; gc; git tag v1 C0"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ось і все що ти маєш знати про git describe. Спробуй виконати describe для різних місць в дереві комітів щоб набити руку.",
            "",
            "Як будеш готовий, просто закоміть щось щоб закінчити цей рівень. Трохи шари :P"
          ]
        }
      }
    ]
  },
  "grabbing-one-commit-name": "Вибираємо всього один коміт",
  "grabbing-one-commit-hint": "Не забувай, що інтерактивний rebase та cherry-pick -- це твої друзі!",
  "grabbing-one-commit-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Локально складені коміти",
            "",
            "Ось ситуація з життя рядового програміста: я намагаюся відслідкувати баг, але це не завжди вдається. Щоб допомогти собі, я додаю кілька дебаг-команд та ще кілька println'ів.",
            "",
            "Всі ці команди для відлагодження та виводу данних знаходяться в своїх власних комітах. Врешті-решт я знаходжу баг, фікшу його та щиро радію!",
            "",
            "От тільки лишається проблема, що потрібно мій фікс перенести з `bugFix` назад в гілку `master`. Якщо я просто зроблю фастфорвард (fast-forwarded) в `master`, тоді в `master` потраплять всі мої println'и, що є зайвим. Має бути інший шлях..."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ми маємо сказати гіту скопіювати лише один коміт. Це все те ж саме, що й у попередніх рівнях, і ми можемо використати ті ж самі команди:",
            "",
            "* `git rebase -i`",
            "* `git cherry-pick`",
            "",
            "для досягнення мети."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "На цьому рівні тобі вирішувати якими командами користуватися, але щоб пройти цей рівень, впевнись що в `master` потрапить коміт, на який посилається `bugFix`."
          ]
        }
      }
    ]
  },
  "juggling-commits-name": "Жонглюємо комітами",
  "juggling-commits-hint": "Перша команда має бути git rebase -i HEAD~2",
  "juggling-commits-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Жонглюємо комітами",
            "",
            "Ось інша ситуація, що доволі часто трапляється. В тебе є якісь зміни (`newImage`) та ще якийсь набір комітів (`caption`), які зв’язані між собою, тому вони знаходяться один над одним в твоєму репозиторії (або один за одним).",
            "",
            "Штука в тому що іноді потрібно зробити невелику модифікацію до попереднього коміту. В цьому випадку, дизайнери хочуть щоб ми трохи змінили розміри `newImage`, не зважаючи на те, що цей коміт знаходиться досить глибоко в історії!!"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ми поборимо цю складність наступним чином:",
            "",
            "* Ми відсортуємо коміти таким чином, щоб той, який ми хочемо змінити, був останнім за допомогою `git rebase -i`",
            "* Ми виконаємо `commit --amend` щоб внести невелику правку до останнього коміту",
            "* Тоді ми відсортуємо коміти в попередньому порядку, за допомогою `git rebase -i`",
            "* І на останок, ми пересунемо master на змінену частину дерева щоб закінчити цей рівень(ти можеш вибрати метод)",
            "",
            "Насправді є кілька способів як виконати поставлену задачу (Я бачу, ти поглядаєш на cherry-pick), і ми розберемося з ними всіма трохи пізніше, але зараз скористаймося саме цим методом.",
            "Зверни увагу на фінальний стан в цьому рівні -- позаяк ми перемістили коміти двічі, кожен з них отримає по апострофу. Ще один апостроф додасться коли ми виконаємо commit --amend.",
            "",
            "Враховуючи сказане вище, я буду порівнювати дерево як за назвою коміта, так і за кількістю апострофів. Щойно дерево цілей та master співпадуть, ти пройдеш цей рівень."
          ]
        }
      }
    ]
  },
  "juggling-commits2-name": "Жонглюємо комітами #2",
  "juggling-commits2-hint": "Не забудь перемістити master на останні зміни!",
  "juggling-commits2-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Жонглюємо комітами #2",
            "",
            "*Якщо ти ще не пройшов Жонглюємо комітами #1 (попередній рівень), будь ласка, зроби це перед тим як продовжити*",
            "",
            "Як ти бачив в попередньому рівні, ми використали `rebase -i` щоб впорядкувати набір комітів. Як тільки потрібний коміт опиняється вгорі, його досить легко змінити за допомогою --amend й потім відсортувати коміти в попередньому порядку.",
            "",
            "Єдина проблема з таким підходом полягає в тому, що виконується досить багато перестановок комітів, що може призвести до конфліктів при виконанні rebase. Спробуймо інший підхід який використовує `git cherry-pick`"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Не забувай, що git cherry-pick вставить коміт з будь-якого місця в HEAD (якщо це не коміт-предок HEAD).",
            "",
            "Ось невелике демо, щоб пригадати:"
          ],
          "afterMarkdowns": [
            "Добре! Продовжуємо"
          ],
          "command": "git cherry-pick C2",
          "beforeCommand": "git checkout -b bugFix; git commit; git checkout master; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Отже, в цьому рівні досягнімо тієї ж мети -- модифікації `C2` -- але без використання `rebase -i`. Я думаю, ти розберешся як це зробити! :D",
            "",
            "Зверни увагу, що точне число апострофів (') в коміті не важливе, важлива тільки відносна різниця. Наприклад, якщо кожен коміт буде містити додатковий апостроф, я все одно зарахую такий розв’язок."
          ]
        }
      }
    ]
  },
  "tags-name": "Git Tags",
  "tags-hint": "ти можеш або зробити checkout коміта напряму чи просто зачекаутити таг!",
  "tags-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Таги в Git",
            "",
            "Як ти вже знаєш з попередніх уроків, гілки досить просто переносити в інші місця, і вони постійно вказують на різні коміти в процесі того? як ті в них додаються. Гілки легко модифікувати, часто тимчасово, й вони постійно змінюються.",
            "",
            "В такому разі, де взяти *постійне* посилання на момент в історії твого проекту? Для таких речей як релізи чи великі мерджі потрібно щось більш стале ніж гілка.",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Є один спосіб! Таги в гіт якраз для цього й були створені -- вони (більш-менш) постійно вказують на певні коміти, й відмічають певні \"віхи\" в житті проекту, на які ти можеш потім посилатись так само як на гілки.",
            "",
            "Але, що важливіше, вони ніколи не переміщуються під час створення нових комітів. Ти не зможеш  \"зачекаутити\" таг а потім закомітити якісь зміни в цей таг -- таги просто відмічають корисні чи символічні місця в дереві комітів.",
            "",
            "Розгляньмо це на практиці"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Спробуймо зробити новий таг на  `C1`, що є прототипом нашої першої версії (вигаданого проекту)"
          ],
          "afterMarkdowns": [
            "Ось і маєш! Все досить просто. Ми назвали наш таг `v1` і він явно посилається на `C1`. Якщо пропустити коміт, git просто відмітить те, на чому знаходиться `HEAD` в данний момент"
          ],
          "command": "git tag v1 C1",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Для того щоб пройти цей рівень, достатньо створити кілька тагів, як показано на візуалізації цілей, і потім зачекаутити `v1`. Зауваж, що ти потрапиш в стан `detached HEAD` -- це тому що ти не можеш напряму комітити в таг `v1`.",
            "",
            "В наступному рівні ми розглянемо більш цікавий приклад роботи з тагами."
          ]
        }
      }
    ]
  },
  "cherry-pick-name": "Знайомство з cherry-pick",
  "cherry-pick-hint": "git cherry-pick базується на іменах комітів!",
  "cherry-pick-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Переміщуємо зміни",
            "",
            "Поки що ми розглядали основи git -- як працювати з комітами та гілками й переміщення по дереву комітів. Цього вже достатньо щоб використовувати 90% фунцкій гіт та мати змогу ефективно працювати з гіт як розробник.",
            "",
            "Решта 10%, тим не менш, можуть бути надзвичайно корисними при роботі зі складними робочими процесами (workflow), чи коли ти чи ще хтось щось зробили не так і ти хочеш це виправити. Наступна концепція з якою ми познайомимось це \"перенесення змін\" -- іншими словами, це можливість розробника переміщувати коміти між гілками в простий та зручний спосіб.",
            "",
            "Це може видаватися складним, але насправді це дуже проста концепція."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Cherry-pick",
            "",
            "Перша команда в цій серії називається `git cherry-pick`. Вона має наступну форму:",
            "",
            "* `git cherry-pick <Коміт1> <Коміт2> <...>`",
            "",
            "Це надзвичайно простий спосіб вказати гіту що потрібно скопіювати серію комітів до поточного розташування (`HEAD`). Персонально я обожнюю `cherry-pick` за його прямолінійнсть, це дуже зрозуміла концепція що не використовує прихованої магії",
            "",
            "Давайте подивимось на практиці!",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Ми бачимо репозиторій де є певні зміни в гілці `side` які ми хочемо скопіювати в  `master`. Для цього можна використати rebase (який ми вже вивчили), але подивимось як з цим впорається cherry-pick."
          ],
          "afterMarkdowns": [
            "Овва! Ми хотіли коміти `C2` та `C4` і git додав їх до поточного розташування. Просто й доступно!"
          ],
          "command": "git cherry-pick C2 C4",
          "beforeCommand": "git checkout -b side; git commit; git commit; git commit; git checkout master; git commit;"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти це рівень, просто скопіюй якісь зміни з трьох гілок показаних на діаграмі в master. В візуалізації видно які коміти потрібно скопіювати.",
            ""
          ]
        }
      }
    ]
  },
  "detached-head-name": "Втрачаємо голову чи detached HEAD",
  "detached-head-hint": "Орієнтуйся по індентифікаторам (hash) комітів.",
  "detached-head-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Прогулянка по Git",
            "",
            "Перед тим як ми перейдемо до складніших можливостей гіта, важливо розуміти різні способи переміщення по дереву комітів твого проекту.",
            "",
            "Дуже важливо щоб тобі було комфортно переміщатись по репозиторію, так як цей навик тобі знадобиться для використання в більшості команд git!",
            "",
            "",
            "",
            "",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## HEAD (голова)",
            "",
            "Спочатку розберемось з \"HEAD\". HEAD це символьне ім’я поточного вибраного коміта -- по суті це той коміт з яким ти зараз працюєш.",
            "",
            "HEAD завжди вказує на найновіший коміт з робочого дерева. Більшість команд що змінюють локальне дерево комітів, також модифікують HEAD.",
            "",
            "Зазвичай HEAD вказує на ім’я бранча (наприклад bugFix). Коли ти комітиш, змінюється статус гілки bugFix й це можна побачити подивившись на  HEAD."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Розберемось з цим на практиці. Зараз ми перевіримо HEAD до та після коміту."
          ],
          "afterMarkdowns": [
            "Ти диви! HEAD весь цей час ховався за гілкою `master`."
          ],
          "command": "git checkout C1; git checkout master; git commit; git checkout C2",
          "beforeCommand": ""
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "### Відокремлюємо голову",
            "",
            "Detached HEAD (відокремлена голова) просто означає що HEAD посилається на коміт, а не на якусь гілку. Ось як це виглядає спочатку:",
            "",
            "HEAD -> master -> C1",
            ""
          ],
          "afterMarkdowns": [
            "А в стані detached head:",
            "",
            "HEAD -> C1"
          ],
          "command": "git checkout C1",
          "beforeCommand": ""
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень, давайте відокремимо голову від гілки `bugFix` й натомість спрямуємо її на якийсь коміт.",
            "",
            "Вкажи цей коміт за його hash (хеш, ідентифікатором). Хеш кожного коміту відображений в кружечку що символізує коміт."
          ]
        }
      }
    ]
  },
  "interactive-rebase-name": "Знайомство з інтерактивним rebase",
  "interactive-rebase-hint": "ти можеш використовувати гілки чи відносні посилання (HEAD~) щоб вказувати ціль для rebase",
  "interactive-rebase-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Інтерактивний Rebase",
            "",
            "Git cherry-pick зручно користуватись, коли ти знаєш які коміти тобі потрібні (_і_ ти знаєш їхні хеші) -- важко вигадати щось простіше.",
            "",
            "Але що робити в ситуації, коли ти не знаєш які коміти потрібні? На щастя git може впоратись і з цим! Для цього випадку використовують інтерактивний rebase -- це найкращий спосіб перевірити серію комітів які потрібно заребейсити.",
            "",
            "Розглянемо це детальніше..."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Інтерактивний rebase це насправді команда  `rebase` з опцією `-i`.",
            "",
            "Якщо додати цю опцію, git відкриє діалог в якому покаже які коміти будуть скопійовані до кінцевого призначення. Він також покаже хеші комітів та їхні повідомлення, що допоможе розібратися що й до чого.",
            "",
            "В \"справжньому\" git, замість UI вікна відкриється файл в сконфігурованому текстовому редакторі, можливо `vim`. Для цього туторіалу я створив невеличке діалогове вікно що поводиться приблизно так само."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Коли відкриється вікно інтерактивного rebase ти можеш зробити три речі:",
            "",
            "* Ти можеш переставити коміти між собою просто змінивши їх порядок в діалозі (в нашому вікні ти зможеш перетягнути їх мишкою).",
            "* Ти можеш повністю пропустити якісь коміти. В туторіалі потрібно вимкнути опцію `pick`, але в справжньому гіт потрібно просто видалити відповідний рядок.",
            "* Також можна розчавити (squash) якісь коміти. На жаль наш туторіал не підтримує цю фічу (так як ми не підтримуємо роботу з файлами), але це дуже зручна опція в справжньому гіт. За її допомогою можна декілька різніх комітів об’єднати в один.",
            "",
            "Чудово! Розгляньмо це на прикладі"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Коли ти натиснеш кнопку, відкриється вікно інтерактивного rebase. Перестав якісь коміти (можеш пропустити якісь якщо хочеш), і подивись що вийде!"
          ],
          "afterMarkdowns": [
            "Ка-бум! Git cкопіював коміти відповідно до того що було вказано в UI"
          ],
          "command": "git rebase -i HEAD~4 --aboveAll",
          "beforeCommand": "git commit; git commit; git commit; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень за допомогою інтерактивного rebase впорядкуй коміти як показано на візуалізації. Пам’ятай що ти завжди можеш використати `undo` чи `reset` щоб виправити помилку :D"
          ]
        }
      }
    ]
  },
  "relative-refs-name": "Відносні посилання",
  "relative-refs-hint": "Не забудь оператор `^`",
  "relative-refs-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Відносні посилання",
            "",
            "Пересуватися по гіту використовуючи хеш комітів може бути трохи напряжно. В справжньому гіті в тебе не буде візуалізації дерева комітів в терміналі, тому доведеться використовувати `git log` щоб подивится хеші комітів.",
            "",
            "Більше того, хеші як правило набагато довші в справжньому гіті. Типовий хеш виглядає як `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`. Без мнемонік не обійтися)...",
            "",
            "З іншого боку git дуже розумно працює з хешами. Він просить вказати рівно стільки літер, скільки потрібно щоб відрізнити один коміт від іншого. Отже, замість довгого хеша зверху можна просто набрати `fed2`."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Як було сказано, вказувати коміти за хешем не найзручніша річ, через це git підтримує відносні посилання. Вони реально круті!",
            "",
            "З відносними посиланнями ти можеш почати з якогось зручного місця  (наприклад гілки `bugFix` чи посилання `HEAD`) й вказати потрібний коміт відносно цього посилання",
            "",
            "Відносні коміти є дуже потужним інструментом, але ми почнемо з двох простих прикладів:",
            "",
            "* Йдемо вверх на один коміт за допомогою `^`",
            "* Йдемо вверх на кілька комітів за допомогою `~<число>`"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Розберемось спочатку з оператором каретки (^). Кожна каретка додана до посилання (напр. до імені коміту) вказує git що потрібно знайти батька посилання до якого застосована каретка.",
            "",
            "Тож `master^` тотожнє до \"перший предок посилання `master`\".",
            "",
            "`master^^` це дідусь (предок другого покоління) посилання `master`",
            "",
            "Давайте перейдемо на коміт трохи вище від master:"
          ],
          "afterMarkdowns": [
            "Бум! Готово. Трохи простіше ніж набирати хеш коміту"
          ],
          "command": "git checkout master^",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Ти також можеш використовувати `HEAD` з відносними посиланнями. Давай використаємо це щоб трошки піднятися по дереву."
          ],
          "afterMarkdowns": [
            "Просто! Ми можемо переміщуватись назад в часі з `HEAD^`"
          ],
          "command": "git checkout C3; git checkout HEAD^; git checkout HEAD^; git checkout HEAD^",
          "beforeCommand": "git commit; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень перемістись на першого предка гілки `bugFix`. Ти опинишся в стані `detach HEAD`.",
            "",
            "Ти, звичайно, можеш вказати хеш, але натомість спробуй користуватися відносними посиланнями!"
          ]
        }
      }
    ]
  },
  "relative-refs2-name": "Відносні посилання №2",
  "relative-refs2-hint": "Тобі потрібно використати як мінімум одне пряме посилання (хеш) щоб пройти цей рівень",
  "relative-refs2-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Оператор \"~\"",
            "",
            "Уявімо, що тобі потрібно піднятися досить високо вгору в дереві комітів. Було б трохи напряжно набирати `^` багато разів, тому Git також має оператор тильда(~).",
            "",
            "",
            "До оператор тильда (не обов’язково) можна дописати справа число, що вказує на яку кількість предків потрібно піднятися вверх. Подивимось на практиці"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте вкажемо на яку кількість комітів повернутися з `~`."
          ],
          "afterMarkdowns": [
            "Ка-бум! Так коротко -- відносні посилання прекрасні."
          ],
          "command": "git checkout HEAD~4",
          "beforeCommand": "git commit; git commit; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Форсуємо гілку",
            "",
            "Тепер ти експерт в відносних посиланнях, давай же *використаємо* їх для справи.",
            "",
            "Один з найуживаніших прийомів де я використовую відносні посилання це переміщення гілок. Ти можеш напряму переспрямувати бранч на якийсь коміт використавши опцію `-f` (force, тобто насильно). Щось на зразок:",
            "",
            "`git branch -f master HEAD~3`",
            "",
            "Переміщує (насильно) гілку master на три предки позад HEAD."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Давайте подивимось на попередню команду в дії"
          ],
          "afterMarkdowns": [
            "Ось і маєш! Відносні посилання дають нам зручний спосіб доступу до коміту`C1` крім того форсування бранчів (`-f`) дає нам можливість швидко перемістити гілку на цей коміт"
          ],
          "command": "git branch -f master HEAD~3",
          "beforeCommand": "git commit; git commit; git commit; git checkout -b bugFix"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Тепер, коли ти побачив відносні посилання та форсування гілок в купі, давай використаємо це щоб пройти поточний рівень.",
            "",
            "Щоб пройти цей рівень, перемісти `HEAD`, `master` та `bugFix` так як показано в візуалізації."
          ]
        }
      }
    ]
  },
  "reversing-changes-name": "Відміна змін в Git",
  "reversing-changes-hint": "Зверни увагу на те що revert та reset приймають різні параметри",
  "reversing-changes-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Відміна змін в Git",
            "",
            "Є декілька шляхів відмини змін в Git. І так само як і коміти, зміни в гіт можна відміняти використовуючи або низькорівневі методи (додавання в коміт окремих файлів) так і високорівневі. Ми зосередемось на останніх.",
            "",
            "Є два основні шляхи відміни змін в Git -- перший це використовувати `git reset` й інший це `git revert`. В наступному слайді ми подивимося на кожний з них",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "## Git Reset",
            "",
            "`git reset` відміняє зміни переміщуючи вказівник гілки назад в історії на старіший коміт. В принципі, можна вважати що це певне \"переписування історії;\" Коли `git reset` перемістить гілку назад буде здаватися, що відмінений коміт взагалі ніколи не створювався.",
            "",
            "Давайте подивимося, як це виглядає:"
          ],
          "afterMarkdowns": [
            "Чудово! Git перемістив посилання гілки master назад до `C1`; тепер наш локальний репозиторій в такому стані, наче коміту `C2` ніколи не було."
          ],
          "command": "git reset HEAD~1",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "## Git Revert",
            "",
            "Команда reset чудово працює для локальних бранчів на власному комп’ютері, але так як вона спричиняє \"переписування історії\", її не можна використовувати в ситуації коли кілька користувачів працюють з цим бранчем",
            "",
            "Для того щоб відкотити зміни й потім *поділитися* цими відкоченими змінами з друзями, потрібно використовувати `git revert`. Давай подивимось на прикладі"
          ],
          "afterMarkdowns": [
            "Дивно, був створений новий коміт, нижче того коміту який ми хотіли відкотити. Це сталося тому що новий коміт `C2'` містить *зміни*  які повністю протилежні змінам `C2`.",
            "",
            "Після revert, ти зможеш зробити push щоб поділитися гілкою з іншими."
          ],
          "command": "git revert HEAD",
          "beforeCommand": "git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень відміни два останні коміти на гілках `local` та `pushed`.",
            "",
            "Зауваж, що `pushed` це віддалена гілка, а `local` це локальна гілка -- це має допомогти з вибором методу."
          ]
        }
      }
    ]
  },
  "many-rebases-name": "Rebase over 9000 разів",
  "many-rebases-hint": "Не забувай, що краще всього буде перемістити master в самому кінці... ",
  "many-rebases-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Ребейсимо кілька гілок",
            "",
            "В нас тут до біса гілок! Перенесімо всі зміни з різних гілок в master.",
            "",
            "Але вище керівництво нам не полегшує життя -- вони хочуть, щоб всі коміти були впорядковані. Це означає, що в результаті коміт `C7'` має бути з самого низу, `C6'` трохи вище, і так далі, все за порядком.",
            "",
            "Якщо ти щось зробиш не так, сміливо використовуй `reset` щоб почати спочатку. Подивись на наш розв’язок і подумай, чи ти можеш обійтись меншою кількістю команд!"
          ]
        }
      }
    ]
  },
  "selective-rebase-name": "Макарони з гілок",
  "selective-rebase-hint": "Переконайся, що все йде за порядком! Спершу гілка `one`, потім `two`, і тільки потім `three`",
  "selective-rebase-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Макарони з гілок",
            "",
            "Ооо Неля! Ну й завданнячко.",
            "",
            "Ми маємо гілку `master`, яка на кілька комітів попереду гілок `one`, `two` та `three`. З незрозумілих причин, нам потрібно оновити ці гілки більш пізніми змінами з мастеру.",
            "",
            "Гілку `one` потрібно впорядкувати і видалити `C5`. Гілку `two` також потрібно впорядкувати, а в гілку `three` потрібно додати ще один коміт!",
            "",
            "Ми повністю покладаємось на тебе -- порівняй свій розв’зок з нашим, який можна подивитись командою `show solution`. "
          ]
        }
      }
    ]
  },
  "clone-name": "Знайомство з clone",
  "clone-hint": "Просто git clone!",
  "clone-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Віддалені репозиторії",
            "",
            "Віддалені репозиторії не є дуже складними. В сучасному світі, де на кожному кроці можна зустріти \"хмарні обчислення\", може видатися, що концепція віддалених репозиторіїв є дуже складною, але насправді вони -- просто звичайні копії твого репозиторію на віддаленому комп’ютері. Зазвичай з цим віддаленим комп’ютером можна зв’язатися через інтернет, що дозволяє обмінюватись комітами.",
            "",
            "Приймаючи до уваги все сказане вище, віддалені репозиторії мають купу чудових властивостей:",
            "",
            "- В першу чергу, віддалені сервери -- це завжди чудова резевна копія (бекап)! Локальний репозиторій дає можливість відкотитися до попереднього стану, але вся інформація зберігається локально. Маючи копії свого репозиторію на віддалених машинах, ти можеш пережити втрату жорсткого диску чи пошкодження данних і продовжити працювати з того місця, на якому закінчив.",
            "",
            "- Що не менш важливо, віддалені репозиторії роблять програмування соціальним! Коли копія твого проекту розміщена в мережі, твої друзі мають змогу допомогти твоєму проекту (чи стягнути останні зміни) без зайвих зусиль.",
            "",
            "Стало дуже популярним користуватися веб-сайтами, що візуалізують активність на віддалених репозиторіях (наприклад [Github](https://github.com/) чи [Phabricator](http://phabricator.org/)), але віддалені репозиторії _завжди_ слугують як основа цих сервісів. Тому важливо розуміти їх!"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Команда, що створює віддалені репозиторії",
            "",
            "До цього моменту, Learn Git Branching концентрувало увагу на основах роботи з _локальним_ репозиторієм (гілкування, злиття гілок, ребейс, тощо). Однак тепер, коли ми вчимо віддалені репозиторії, нам потрібно налаштувати середовище для подальших уроків. `git clone` впорається з цим завданням.",
            "",
            "В принципі, `git clone` в справжньому git -- це команда для створення _локальної_ копії віддаленого репозиторію (наприклад з github). Але у Learn Git Branching ми використовуватимемо цю команду по-іншому -- `git clone` буде створювати віддалений репозиторій з локального. Я згодний, що це виходить трохи догори-дригом, але це допоможе створити зв’язок в голові між клонуванням та роботою з віддаленми репо, тому поки що будемо використовувати її таким чином.",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Низький старт - просто подивімося, як віддалений репозиторій виглядає (в нашій візуалізації).",
            ""
          ],
          "afterMarkdowns": [
            "Ось і все! Тепер ми маємо віддалений репозиторій нашого проекту. Він виглядає досить схоже, хіба що деякі візуальні елементи інші, щоб краще показати різницю -- в наступних рівнях ти навчишся ділитися роботою між цими репозиторіями."
          ],
          "command": "git clone",
          "beforeCommand": ""
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень, просто зроби `git clone` свого поточного репозиторію. Справжні знання ти отримаєш в подальших рівнях."
          ]
        }
      }
    ]
  },
  "fake-teamwork-name": "Симуляція колективної роботи",
  "fake-teamwork-hint": "пам’ятай що ти можеш вказати кількість фейкових комітів",
  "fake-teamwork-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Симулюємо співпрацю",
            "",
            "Зараз ми знаходимося в незручному становищі -- в деяких із наступних уроків нам потрібно буде пояснити як витягнути зміни з віддаленого репозиторію, що були туди додані іншим учасником.",
            "",
            "Це означає, що нам треба \"вдавати\", що віддалений репозиторій був модифікований твоїм колегою / друзями / небайдужими, іноді на специфічній гілці чи коміті.",
            "",
            "Щоб зробити це, ми додали влучно названу команду `git fakeTeamwork` (симуляціяКолективноїРоботи)! Насправді, з симуляцією колективної роботи стикався мабуть кожен, хто працював в колективі, тож перейдімо до прикладів..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "За замовчуванням `fakeTeamwork` просто додасть коміт в гілку `master`"
          ],
          "afterMarkdowns": [
            "Є -- до віддаленого репозиторію додався ще один коміт, проте ми ще його не звантажили, оскільки ще не виконали `git fetch`."
          ],
          "command": "git fakeTeamwork",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Ти також можеш вказати кількість комітів чи гілку, в яку потрібно додати коміти."
          ],
          "afterMarkdowns": [
            "Виконавши одну команду ми симулювали колегу, що запушив три коміти в гілку `foo` на віддаленому репозиторії."
          ],
          "command": "git fakeTeamwork foo 3",
          "beforeCommand": "git branch foo; git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Наступні рівні будуть доволі складними, тому, щоб підготуватись, на цьому рівні теж доведеться не солодко.",
            "",
            "Створи віддалений репозиторій (за допомогою `git clone`), зроби кілька фіктивних змін, зроби кілька комітів локально, й підвантаж віддалені зміни. Це як кілька уроків в одному!"
          ]
        }
      }
    ]
  },
  "fetch-name": "Git fetch",
  "fetch-hint": "Просто виконай git fetch!",
  "fetch-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Fetch",
            "",
            "Робота з віддаленими git-репозиторіями зводиться до передачі данних _до_ та _з_ інших репозиторіїв. Можливість передавати коміти дозволяє нам ділитися будь-якою інформацією, що відслідковується gitом (а отже, виконаною роботою, новими файлами, ідеями, листами, тощо).",
            "",
            "На цьому уроці ми навчимося витягати дані _з_ віддаленого репозиторію -- команда, що відповідає за це, зручно називається `git fetch` (fetch - англ. витягнути чи дістати).",
            "",
            "Зауваж, що коли ми оновлюємо наш віддалений репозиторій, наші _віддалені_ гілки теж оновляться. Про це ми говорили на попередньому уроці."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Перед тим, як почати розбиратися з `git fetch`, спробуймо його в дії! Тут ми маємо віддалений репозиторій, що містить два коміти, яких немає в нашому локальному сховищі."
          ],
          "afterMarkdowns": [
            "Ось, маєш! Коміти `C2` та `C3` було завантажено до нашого локального сховища й наша віддалена гілка `o/master` була відповідно оновлена."
          ],
          "command": "git fetch",
          "beforeCommand": "git clone; git fakeTeamwork 2"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Що робить fetch",
            "",
            "`git fetch` виконує дві основні дії, і тільки дві дії. Він:",
            "",
            "* звантажує коміти, які містить віддалене сховище, але яких немає в локальному сховищі, та...",
            "* оновлює посилання віддаленого бранчу (наприклад, `o/master`)",
            "",
            "Якщо коротко, `git fetch` приводить репрезентацію віддаленого репозиторію в локальному сховищі до _актуального_ стану справжнього віддаленого репозиторію.",
            "",
            "Якщо ти пам’ятаєш з попереднього уроку, ми тоді зауважили, що віддалені гілки відображають стан віддаленого репозиторію _від_ останнього разу, коли ми синхронізувались з віддаленим репозиторієм. `git fetch` якраз і відповідає за синхронізацію з віддаленим сховищем! Сподіваюсь, що зв’язок між віддаленими гілками `git fetch` тепер є очевидним.",
            "",
            "Як правило, `git fetch` працює з віддаленими сховищами через інтернет (через протоколи `http://` чи `git://`).",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Чого не робить fetch",
            "",
            "Тим не менш, `git fetch` нічого не змінює в _твоєму_ локальному стані. Він не оновить твою гілку `master` і не змінить того, як наразі виглядає локальна файлова система.",
            "",
            "Це важливо зрозуміти, тому що багато розробників думають, що `git fetch` оновить їхні локальні данні до стану віддаленого репозиторію. Він дійсно звантажить всі потрібні дані, щоб це зробити, але він _не змінить_ автоматично жодних локальних файлів. Ми вивчимо команди, які це роблять, в наступних уроках :D",
            "",
            "Отже, зрештою, ти можеш вважати що `git fetch` просто звантажує нову інформацію з віддаленого сховища."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень просто виконай `git fetch` і звантаж всі коміти!"
          ]
        }
      }
    ]
  },
  "fetch-args-name": "Аргументи для fetch",
  "fetch-args-hint": "Зверни увагу на те, що номери комітів можуть змінюватися! Слайди уроку можна переглянути ще раз командою \"help level\"",
  "fetch-args-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Аргументи git fetch",
            "",
            "Отже, ми вже вивчили все про аргументи git push, про корисний параметр `<place>` і про формат запису з двокрапкою (`<source>:<destination>`). Чи знадобляться нам ці зання при вивченні `git fetch`?",
            "",
            "Ще б пак! Аргументи для `git fetch` насправді *дуже, дуже* схожі на `git push`. Принцип той самий, з точністю до напрямку (бо ми звантважуємо коміти, а не завантажуємо).",
            "",
            "Розгляньмо це крок за кроком..."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Параметр `<place>`",
            "",
            "Якщо вказати параметр `<place>` для команди git fetch, наприклад, так:",
            "",
            "`git fetch origin foo`",
            "",
            "git піде у віддалену гілку `foo`, візьме всі коміти, яких немає локально і закине в локальну гілку `o/foo`.",
            "",
            "Подивімось на це в дії (просто щоб пригадати)."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Вказуючи `<place>`..."
          ],
          "afterMarkdowns": [
            "Ми звантажуємо коміти лише з `foo` і кладемо їх в `o/foo`"
          ],
          "command": "git fetch origin foo",
          "beforeCommand": "git branch foo; git clone; git fakeTeamwork foo 2"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ти можеш спитати, чому git закинув ці коміти в гілку `o/foo` замість того, щоб покласти їх відразу в локальну гілку `foo`? Я думав, що параметр `<place>` одночасно вказує місце звідки взяти і куди поставити?",
            "",
            "Ну, git робить невеликий виняток в цьому випадку, оскільки ти, ймовірно, маєш якусь роботу в `foo`, і не хочеш там нічого зіпсувати! Пригадай з попереднього уроку про `git fetch` -- він не оновлює твої локальні (не віддалені -- без `o/`) гілки, він тільки звантажує коміти (так, щоб їх можна було переглянути/змерджити пізніше).",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "\"Ну, в такому разі, що буде, якщо явно вказати і джерело і призначення `<source>:<destination>`?\"",
            "",
            "Якщо ти почуваєшся достатньо впевненим і хочеш звантажити віддалені коміти *прямо* в свою локальну гілку, тоді -- справді, ти можеш так написати, використавши синтаксис з двокрапкою. Єдиний виняток -- таким способом не можна витягувати зміни в поточну локальну гілку, в будь-яку іншу -- без проблем.",
            "",
            "Тепер в нас `<source>` вказує на *віддалений репозиторій*, а `<destination>` -- на *локальне* місце, куди звантажаться коміти. Це повна протилежність тому, як було в git push, що, зрештою, має сенс, адже ми передаємо дані у протилежному напрямку!",
            "",
            "Насправді, розробники рідко використовують такий спосіб на практиці. І він показаний тут лише для повноти описання наскільки `fetch` і `push` схожі, відрізняючись лише напрямом дії."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Подивімось на це божевілля в дії:"
          ],
          "afterMarkdowns": [
            "Ого! Дивись, git прийняв `foo~1` за джерело, і звантажив коміти в `bar` (локальна гілка). Зауваж, що `foo` і `o/foo` не оновлювались, оскільки ми явно вказали звідки і куди передавати коміти."
          ],
          "command": "git fetch origin foo~1:bar",
          "beforeCommand": "git branch foo; git clone; git branch bar; git fakeTeamwork foo 2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А якщо вказаного місця призначення не існує на момент виконання команди? Погляньмо на попередній слайд, але без гілки `bar`."
          ],
          "afterMarkdowns": [
            "Бачиш, все як і в випадку з git push. Git створив локальну гілку-призначення перед звантаженням, так само як створить гілку-призначення на віддаленій стороні перед пушем (якщо її не існувало, звичайно)."
          ],
          "command": "git fetch origin foo~1:bar",
          "beforeCommand": "git branch foo; git clone; git fakeTeamwork foo 2"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Без аргументів?",
            "",
            "Якщо `git fetch` запущено без аргументів, він просто звантажить всі коміти з віддаленого репозиторія в віддалені (`o/`) гілки..."
          ],
          "afterMarkdowns": [
            "Все дуже просто, але варто було згадати ще раз."
          ],
          "command": "git fetch",
          "beforeCommand": "git branch foo; git clone; git fakeTeamwork foo; git fakeTeamwork master"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Гаразд, годі балакати! Щоб пройти цей рівень, звантаж лише вказані на візуалізації коміти. Прояви фантазію, підбираючи команди!",
            "",
            "Тобі потрібно вказати і джерело і призначення для обидвох fetch-команд. Слідкуй за змінами на візуалізації, ID комітів можуть змінюватися!"
          ]
        }
      }
    ]
  },
  "fetch-rebase-name": "Розбіжності в історії",
  "fetch-rebase-hint": "перевірте порядок в візуалізації цілі",
  "fetch-rebase-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Розбіжності в історії",
            "",
            "Ми розглянули як витягувати (`pull`) коміти інших та як завантажувати (`push`) свої власні коміти. Це виявилось не надто складно, то як же так, що в людей дуже часто виникають з цим труднощі?",
            "",
            "Основна складність полягає в тому, що історія різних репозиторіїв *розбігається*. Перед тим, як вдатися в деталі, подивімося як це виглядає на прикладі...",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Уяви, що ти склонував репозиторій в понеділок і почав працювати над якоюсь фічею. В пятницю фіча готова і ти хочеш повернути її назад (в апстрім) -- але що це? Твої колеги, грець їм, вже встигли вкомітити купу коду що робить твою фічу застарілою (і не дуже доречною). Вони вже запушили ці коміти в публічний репозиторій, й тепер *твоя* робота базується на *старій* версії продукту, що вже не актуальна.",
            "",
            "В цьому випадку команда `git push` неоднозначна. Коли ти виконаєш `git push`, гіт повинен змінити віддалений репозиторій до того стану, на якому він знаходився в понеділок? Чи він має додати твій код і залишити код твоїх колег? Чи він має повністю проігнорувати твої зміни, оскільки вони застаріли?",
            "",
            "Через такі неоднозначності в цій ситуації (коли історія розійшлася), git не дозволить тобі запушити твої зміни. Він фактично змушує тебе інтегрувати останні зміни з віддаленого репозиторію перед тим як ти зможеш завантажити на нього свої напрацювання."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Але, забагато розмов! Подивімось на ділі!"
          ],
          "afterMarkdowns": [
            "Бачиш? Нічого не сталося тому що остання команда не виконалася. `git push` не спрацював тому що твій недавній коміт `C3` базується на коміті `C1`. Але віддалений репо вже прейшов на`C2`, тому git відхилив твій push."
          ],
          "command": "git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Як вийти з цієї ситуації? Дуже просто! Все, що треба -- це оновити свої напрацювання так, щоб вони базувалися на останніх змінах з віддаленої гілки.",
            "",
            "Є кілька шляхів як цього досягнути, але найпростіший -- це перемістити свою роботу 'вперед' за допомогою rebase. Спробуймо і погляньмо як це виглядає."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Тепер якщо виконати rebase перед push..."
          ],
          "afterMarkdowns": [
            "Ка-бум! Ми оновили наш локальний образ віддаленого репозиторію за допомогою `git fetch`, заребейсили наші напрацювання відповідно до змін у віддаленому репо, й завантажили їх за допомогою `git push`."
          ],
          "command": "git fetch; git rebase o/master; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чи є якийсь інший спосіб оновити свої напрацювання, коли віддалений репозиторій пішов вперед? Звісно! Спробуймо зробити те ж саме, але натомість за допомогою `merge` (злиття).",
            "",
            "Хоча `git merge` і не переміщує твою роботу (а просто створює натомість коміт злиття чи merge commit), це -- ще один спосіб сказати git, що ти інтегрував останній стан віддаленого репозиторію в свої зміни. Це працює тому, що тепер віддалена гілка є *предком* твоєї гілки, а отже твої останні коміти інтегрують в собі всі коміти з віддаленої гілки.",
            "",
            "Невелика демонстрація..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Тепер ми зробимо merge замість rebase..."
          ],
          "afterMarkdowns": [
            "Ка-бум! Ми оновили наш локальний образ віддаленої гілки за допомогою `git fetch`, *змерджили* нові напрацювання з власними (щоб відобразити останні зміни у віддаленій гілці), й відіслали їх за допомогою `git push`"
          ],
          "command": "git fetch; git merge o/master; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Чудово! Чи можу я це зробити, використовуючи меншу кількість команд?",
            "",
            "Звісно -- ти ж знаєш, що `git pull` це просто коротша форма для git fetch а потім git merge. Натомість, `git pull --rebase` це коротка форма для git fetch а потім git rebase!",
            "",
            "Спробуймо використати ці коротші команди."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Спочатку з `--rebase`..."
          ],
          "afterMarkdowns": [
            "Те саме, що й раніше! Просто трохи коротше."
          ],
          "command": "git pull --rebase; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А тепер просто з `pull`"
          ],
          "afterMarkdowns": [
            "Знову, так як і було!"
          ],
          "command": "git pull; git push",
          "beforeCommand": "git clone; git fakeTeamwork; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Робочий процес, що складається з fetch, rebase/merge і push є дуже широковживаним. В наступних уроках ми розглянемо складніші версії цього процесу, а наразі спробуймо його виконати.",
            "",
            "Щоб пройти цей рівень, виконай наступні кроки:",
            "",
            "* Склонуй свій репозиторій",
            "* Зроби симуляцію командної роботи (1 коміт)",
            "* Зроби власний коміт (1 коміт)",
            "* Опублікуй свої напрацювання за допомогою *rebasе*"
          ]
        }
      }
    ]
  },
  "merge-many-features-name": "Мердж з віддаленим репозиторієм",
  "merge-many-features-hint": "Уважно подивись як має виглядати результат!",
  "merge-many-features-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Чому б не змерджити?",
            "",
            "Для того, щоб віддалений сервер прийняв твої зміни, треба *об'єднати* їх з останніми змінами на сервері. Це означає ребейс *або* мердж з віддаленою гілкою (напр. `o/master`).",
            "",
            "Хмм, якщо можна використати один із цих методів, для чого нам додаткові уроки про ребейс? Чому ніхто не любить `merge`, працюючи з віддаленим сервером?",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "В спільноті розробників давно ведуться суперечки щодо переваг і недоліків мерджингу і ребейсу. Ось головні з них для ребейсу:",
            "",
            "За:",
            "",
            "* Ребейс дозволяє тримати дерево комітів чистим, оскільки все вибудовується в пряму лінію;",
            "",
            "Проти:",
            "",
            "* Ребейс змінює історію в дереві комітів.",
            "",
            "Наприклад, коміт `C1` можна ребейснути *на* `C3`. Як результат `C1'` буде йти після `C3`, хоча насправді його зробили раніше.",
            "",
            "Деякі розробники люблять зберігати історії і тому вибирають мерджинг. Інші (як і я) воліють мати чисте дерево комітів і віддають перевагу ребейсу. Це питання смаку :D"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "На цьому рівні спробуймо вирішити попереднє завдання з використанням *мерджу*. Можливо вийде не так охайно, але добре покаже різницю в підходах."
          ]
        }
      }
    ]
  },
  "pull-name": "Git pull",
  "pull-hint": "Просто виконай git pull !",
  "pull-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Pull",
            "",
            "Тепер, коли ми знаємо як витягувати дані з віддаленого репозиторію за допомогою `git fetch`, спробуймо оновити нашу робочу копію відповідно до цих данних!",
            "",
            "Насправді, є кілька шляхів як цого досягнути -- щойно нові коміти з’явилися локально, ти можеш додавати їх в бранчі так само, як звичайні коміти. Це означає що ти можеш виконувати команди:",
            "",
            "* `git cherry-pick o/master`",
            "* `git rebase o/master`",
            "* `git merge o/master`",
            "* тощо.",
            "",
            "Насправді, процес *витягування* віддалених змін й подальший *мерджинг* їх є настільки популярним, що гіт пропонує спеціальну команду, що виконує ці дві дії за один раз! Ця команда називається `git pull`."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Спершу виконаймо по черзі `fetch`, а потім `merge`"
          ],
          "afterMarkdowns": [
            "Ка-бум -- ми звантажили `C3` за допомогою `fetch` і потім змерджили їх, використавши `git merge o/master`. Тепер наша гілка `master` відповідає гілці з віддаленого сховища (в цьому випадку, з назвою `origin`)"
          ],
          "command": "git fetch; git merge o/master",
          "beforeCommand": "git clone; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Що трапиться, якщо натомість використати `git pull`?"
          ],
          "afterMarkdowns": [
            "Те саме! Тепер очевидно що `git pull` -- це просто швидкий спосіб зробити `git fetch`, а потім змерджити завантажену гілку."
          ],
          "command": "git pull",
          "beforeCommand": "git clone; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ми розглянемо `git pull` більш детально пізніше (включаючи різні опції та аргументи), наразі просто спробуймо цю команду.",
            "",
            "Не забувай -- щоб пройти цей рівень, достатньо використати `fetch`, а потім `merge`, але це буде тобі коштувати одну зайву команду :P"
          ]
        }
      }
    ]
  },
  "pull-args-name": "Аргументи pull",
  "pull-args-hint": "Пам'ятай, що ти можеш створювати нові гілки, використовуючи fetch/pull з аргументами",
  "pull-args-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Аргументи git pull",
            "",
            "Зараз, коли ти знаєш майже *все*, що можна знати про аргументи для `git fetch` і `git push`, дійсно майже нема чого розповідати про git pull :)",
            "",
            "Це тому, що git pull, зрештою, *просто* зручне об'єднання fetch і merge. Його можна собі уявляти як git fetch і git merge виконані з *однаковими* аргументами.",
            "",
            "Це працює незалежно від складності переданих аргументів. Розгляньмо:"
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ось декілька еквівалентних команд git:",
            "",
            "`git pull origin foo` це те саме, що й:",
            "",
            "`git fetch origin foo; git merge o/foo`",
            "",
            "А...",
            "",
            "`git pull origin bar~1:bugFix` -- це аналог:",
            "",
            "`git fetch origin bar~1:bugFix; git merge bugFix`",
            "",
            "Бачиш? git pull -- це просто зручне скорочення для fetch + merge. А все, про що дбає git pull -- це те, куди в результаті підуть коміти (а про це йому говорить аргумент `destination`).",
            "",
            "Розгляньмо демонстрацію:"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Якщо ми вказуємо місце призначення для fetch, fetch виконується як звичайно, але мердж відбудеться з тим, що ми щойно стягнули"
          ],
          "afterMarkdowns": [
            "От бачиш, вказавши `master`, ми звантажили коміти в `o/master`, як завжди. Потім змерджили `o/master` в поточну гілку."
          ],
          "command": "git pull origin master",
          "beforeCommand": "git clone; go -b bar; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Чи це працює також при вказанні `source` і `destination`? І не сумнівайся! Ось приклад:"
          ],
          "afterMarkdowns": [
            "Ого, стільки роботи однією командою. Ми створили локальну гілку з назвою `foo`, звантажили в неї коміти з віддаленого master, а потім змерджили `foo` в поточну гілку `bar`!"
          ],
          "command": "git pull origin master:foo",
          "beforeCommand": "git clone; git fakeTeamwork; go -b bar; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Добре, для завершення спробуй досягти стану репозиторію, показаного на візуалізації. Треба буде звантажити відсутні коміти, створити нові гілки і змерджити їх в інші гілки, але не надто великою кількістю команд! :P"
          ]
        }
      }
    ]
  },
  "push-name": "Git push",
  "push-hint": "Пам’ятай, що перед тим як щось push-нути потрібно склонувати репозиторій!",
  "push-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Git Push",
            "",
            "Гаразд, я витягнув останні зміни та інтегрував їх до своїх локальних напрацювань. Все добре... але як мені поділится _своїми_ змінами з рештою учасників?",
            "",
            "Отже, надсилання данних є, по-суті, протилежним звантажуванню данних. А який антонім до `git pull` (притягнути)? `git push` (відштовхнути)!",
            "",
            "`git push` використовується для надсилання _локальних_ змін на вказаний віддалений репозиторій; ця команда оновлює віддалений репозиторій, інтегруючи нові коміти. Після виконання `git push` всі твої друзі зможуть звантажити твої напрацювання з віддаленого сховища.",
            "",
            "Ти можеш вважати, що `git push` \"публікує\" твої напрацювання. В цієї команди є кілька особливостей, які ми скоро розглянемо, але почнімо з початку...",
            "",
            "*Зауваження: поведінка `git push` без параметрів різниться в залежності від налаштування git з назвою `push.default`. Значення за замовчуванням цього налаштування залежить від версії твого git, але в наших уроках ми будемо вважати що воно дорівнює `upstream`. Це не вкрай важливо, але буде корисно перевірити це налаштування перед тим як пушити свій проект.*"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Ось ми маємо деякі зміни яких нема в віддаленому сховищі. Надішлімо їх!"
          ],
          "afterMarkdowns": [
            "Ось, маєш -- віддалене сховище отримало  `C2`, гілку `master` на ньому було оновлено й тепер вона посилається на `C2`, а наше *власне* відображення віддаленого репо  (`o/master`) було також оновлено. Все синхронізовано!"
          ],
          "command": "git push",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень, просто надішли два коміти у віддалений репозиторій. Але прищібнись, скоро наші уроки стануть значно важчими!"
          ]
        }
      }
    ]
  },
  "push-args-name": "Аргументи git push",
  "push-args-hint": "Завжди можна подивитися останній слайд діалогу за допомогою \"objective\"",
  "push-args-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Аргумeнти git push",
            "",
            "Чудово! А зараз, коли ти знаєш все про відслідковування віддалених гілок, ми можемо розглянути \"магію\", що відбувається при git push, fetch, і pull. Ми розглянемо лише окремі команди для розуміння загального принципу.",
            "",
            "Спочатку розгляньмо `git push`. З уроку про відслідковування віддалених гілок ми знаємо, що git визначає куди і в *яку* гілку робити push, дивлячись на локальну поточну гілку (і віддалену, за якою вона \"слідкує\"). Це поведінка `push` без аргументів, але git push може приймати необов'язкові аргументи в форматі:",
            "",
            "`git push <remote> <place>`",
            "",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Ви спитаєте, що таке аргумент `<place>`? Ми скоро вдамося в детальні пояснення, але спочатку -- приклад. Виконання команди:",
            "",
            "`git push origin master`",
            "",
            "буквально перекладається як:",
            "",
            "*Піди в гілку, що називається \"master\" в моєму репозиторії, візьми всі коміти, піди у віддалений \"master\", що називається \"origin\". Додай ті коміти, яких немає в цій гілці і надрукуй, що саме ти зробив.*",
            "",
            "Вказуючи `master` в якості аргумента \"place\", ми сказали git-у, *звідки* взяти коміти і *куди* їх додати. (\"Place\") - фактично точка синхронізації двох репозиторіїв.",
            "",
            "Пам'ятайте, що оскільки ми надали git-у всю необхідну інформацію (вказавши обидва аргументи), не має значення яка гілка є зараз поточною!"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Розгляньмо приклад використання аргументів. Зверніть увагу на поточну гілку в цьому прикладі."
          ],
          "afterMarkdowns": [
            "Ось так! `master` у віддаленому репозиторії оновився, оскільки ми вказали його в аргументах."
          ],
          "command": "git checkout C0; git push origin master",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А якщо не вказувати аргументів? Що станеться?"
          ],
          "afterMarkdowns": [
            "Команда поверне помилку (як можна побачити), оскільки локальний `HEAD` не співпадає з відповідною віддаленою гілкою."
          ],
          "command": "git checkout C0; git push",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Гаразд, на цьому рівні оновімо віддалені гілки `foo` і `master`. Для ускладнення ми заборонимо використовувати `git checkout`!",
            "",
            "*Пам'ятай, віддалені гілки позначені префіксом `o/`, оскільки повний префікс `origin/` не влазить в наш UI. Але не хвилюйся ",
            "про це... ти можеш використовувати `origin` посилаючись на віддалений репозиторій.*"
          ]
        }
      }
    ]
  },
  "push-args2-name": "Розширені аргументи git push!",
  "push-args2-hint": "Пам'ятай, ти завжди можеш визнати поразку і підглянути рішення командою \"show solution\" :P",
  "push-args2-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Детальніше про аргумент `<place>`",
            "",
            "З попереднього уроку нам відомо, що коли ми вказуємо `master` в якості аргумента place для git push, ми задаємо і гілку, *з якої* брати нові коміти, і гілку *до якої* їх буде перенесено.",
            "",
            "Тут ти можеш задуматись, а чи можуть гілки, звідки беремо, і куди переносимо, бути різними? Що, коли потрібно коміти з локальної гілки `foo` перенести у віддалену гілку `bar`?",
            "",
            "Нажаль в git це неможливо... жартую! Звісно, що можливо :)... git просто неймовірно гнучкий (іноді аж занадто).",
            "",
            "Подивімося як це робиться..."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Для того, щоб в одному аргументі `<place>` вказати і місце звідки і куди, треба їх просто розділити двокрапкою:",
            "",
            "`git push origin <source>:<destination>`",
            "",
            "Такий запис називають \"colon refspec\". Тут refspec - це просто зручна назва місця, яке git може ідентифікувати (наприклад, гілка `foo` чи просто `HEAD~1`)",
            "",
            "Можливість вказати два різних місця дає велику свободу і гнучкість в роботі з віддаленим репозиторієм. Подивімось демонстрацію!"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Пам'ятай, `source` -- це будь-яка назва місця, зрозуміла гіту:"
          ],
          "afterMarkdowns": [
            "Овва! Це доволі незвична команда, але тут все має сенс -- git, знаючи куди вказує `foo^`, завантажив на віддалену сторону ще відсутні там коміти і оновив місце призначення."
          ],
          "command": "git push origin foo^:master",
          "beforeCommand": "git clone; go -b foo; git commit; git commit"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "А що, коли вказаного місця призначення не існує? Нема проблем! Просто вкажи назву гілки і гіт створить її на віддаленому сервері."
          ],
          "afterMarkdowns": [
            "Спритно, еге-ж? :D"
          ],
          "command": "git push origin master:newBranch",
          "beforeCommand": "git clone; git commit"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "На цьому рівні спробуй досягти стану ропозиторію, показаного у візуалізації і пам'ятай про формат запису з двокрапкою:",
            "",
            "`<source>:<destination>`"
          ]
        }
      }
    ]
  },
  "push-many-features-name": "Push Maйстер!",
  "push-many-features-hint": "Пам'ятай, ти в будь-який момент можеш використовувати команди undo або reset",
  "push-many-features-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Мердж гілок з фічами",
            "",
            "Тепер, коли ти вже впевнено володієш засобами `pull` та `push`, час перевірити ці знання в новому процесі.",
            "",
            "Зазвичай розробники працюють над якимось фічами в окремій гілці (не в `master`), а потім, коли роботу закінчено, інтегрують її. Це схоже на попередній урок (де окремі гілки пушили у віддалений репозиторій), але тут буде ще один додатковий крок.",
            "",
            "Деякі розробники виконують push і pull лише в гілці `master` -- тож `master` завжди буде актуальним і синхронізованим з віддаленою гілкою (`o/master`).",
            "",
            "Отже для цього процесу ми об'єднуємо дві речі:",
            "",
            "* інтеграцію гілки з фічею в `master`, і",
            "* пул та пуш для синхронізації з віддаленим репозиторієм"
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Пригадаймо коротко як оновити `master` і запушити свої зміни."
          ],
          "afterMarkdowns": [
            "Ми виконали дві команди, які:",
            "",
            "* заребейсили нашу роботу поверх віддалених комітів, і",
            "* опублікували наші зміни у віддаленому репозиторії"
          ],
          "command": "git pull --rebase; git push",
          "beforeCommand": "git clone; git commit; git fakeTeamwork"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Цей рівень доволі величенький -- ось, що треба буде зробити:",
            "",
            "* Є три гілки з фічами -- `side1` `side2` та `side3`",
            "* Ми хочемо запушити кожну з них по черзі у віддалений репозиторій",
            "* Віддалений репозиторій теж змінився, тож нам потрібно об'єднати всі ці зміни",
            "",
            ":O Чимале завдання! Успіху! Виконання цього рівня буде великим кроком."
          ]
        }
      }
    ]
  },
  "remote-branches-name": "Віддалені гілки",
  "remote-branches-hint": "Звертайте увагу на послідовність -- спочатку коміт в мастер!",
  "remote-branches-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Віддалені гілки",
            "",
            "Тепер, коли ти познайомився з `git clone` в дії, розгляньмо деталі й подивімося, що дійсно змінилося.",
            "",
            "Перше, що ти міг помітити -- це те, що з’явився новий бранч з назвою `o/master`. Такі гілки називаються  _віддаленими_ (remote); віддалені гілки в гіт відіграють в певному сенсі унікальну роль, тому в них є деякі спеціальні властивості, непритаманні іншим гілкам.",
            "",
            "Віддалені гілки відображають _стан_ віддалених репозиторіїв (точніше, стан віддаленого репо на момент останньої синхронізації). Вони дозволяють  відрізняти та відслідковувати локальні зміни та зміни інших учасників, що є дуже важливим для успішної синхронізації роботи між різними репозиторіями.",
            "",
            "Важливою властивістю віддалених гілок є те, що коли перейти на них, ти опинишся в стані `detached HEAD`. Git робить це спеціально, так як неможливо працювати з ними напряму; ти маєш працювати в локальній гілці й по необхідності синхронізуватися з віддаленим репозиторієм (після чого віддалену гілку буде оновлено)."
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Що за `o/`? Або Римський салют",
            "",
            "Ти, можливо, здогадуєшся для чого потрібен префікс `o/` на віддалених гілках. Так, існує (примусове) правило іменування віддалених гілок  -- вони відображаються в форматі:",
            "",
            "* `<ім’я віддаленого репо>/<ім’я гілки>`",
            "",
            "Отже, якщо розглянути гілку з назвою `o/master`, то ім’я гілки -- це `master` а ім’я віддаленого репозиторію -- це `o`.",
            "",
            "Більшість розробників насправді називають ім’я головного віддаленого репозиторію `origin` (початок), а не `o`. Це настільки поширена практика, що гіт автоматично називає віддалений репозиторій `origin` коли ти його клонуєш.",
            "",
            "На жаль повністю ім’я `origin` не влазить в наш UI, натомість ми будемо використовувати коротше `o` :( Просто не забудь, коли будеш використовувати звичайний гіт, що твій віддалений репо скоріш за все називається `origin`!",
            "",
            "Це багато інформації, погляньмо як це працює на прикладі."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Зробімо checkout віддаленої гілки й подивімось, що буде"
          ],
          "afterMarkdowns": [
            "Як бачиш, git перейшов в стан `detached HEAD` і не оновив `o/master` коли ми зробили новий коміт. Це тому, що `o/master` буде оновлено лише тоді, коли буде оновлено віддалений репозиторій."
          ],
          "command": "git checkout o/master; git commit",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Щоб пройти цей рівень, зроби один коміт в `master`, а потім переключись в `o/master` і закомітся ще раз. Це наглядно продемонструє поведінку віддалених гілок, а також покаже як зміни впливають на стан віддаленого репозиторію."
          ]
        }
      }
    ]
  },
  "source-nothing-name": "Нема джерела",
  "source-nothing-hint": "Команда branch недоступна на цьому уроці, користуйся командою fetch!",
  "source-nothing-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Неочевидні способи використання `<source>`",
            "",
            "Git має два хитрі способи використання `<source>`. Обидва випливають з факту, що формально (і цілком легально) ти можеш не вказувати джерело (`source`) як для git push так і для git fetch. Ось, як саме ти можеш це зробити:",
            "",
            "* `git push origin :side`",
            "* `git fetch origin :bugFix`",
            "",
            "Погляньмо, що в результаті вийде..."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Що буде, якщо спробувати запушити \"ніщо\" у гілку віддаленого репозиторію? Git її видалить!"
          ],
          "afterMarkdowns": [
            "Ось, ми успішно видалили гілку `foo` на віддаленому сервері, запушивши в неї \"ніщо\". Ну, ніби все правильно..."
          ],
          "command": "git push origin :foo",
          "beforeCommand": "git clone; git push origin master:foo"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "І останнє, звантаження \"нічого\" в локальний репозиторій створює нову гілку"
          ],
          "afterMarkdowns": [
            "Дуже дивно, але такий він, git!"
          ],
          "command": "git fetch origin :bar",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Це швидкий рівень -- просто видали одну віддалену гілку і створи нову локальну гілку, використовуючи `git fetch`!"
          ]
        }
      }
    ]
  },
  "tracking-name": "Слідкуємо за віддаленим репозиторієм",
  "tracking-hint": "Пам'ятай, є два способи слідкувати за віддаленим репозиорієм!",
  "tracking-start-dialog": {
    "childViews": [
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Гілки віддаленого стеження",
            "",
            "Одна з речей в попередніх уроках, яка могла виглядати, наче \"магія\" -- це те, що гіт якось знає, що локальна гілка `master` відповідає віддаленій `o/master`. Звичайно, ці гілки мають схожі назви, і виглядає логічним співставити віддалену гілку `master` з локальною `master`, однак цей зв'язок найкраще видно в двох випадках:",
            "",
            "* Під час операції `pull`, коміти попадають в `o/master`, а вже потім *мерджаться* в локальний `master`. Гілка в яку відбудеться мердж якраз і визначається цим зв'язком.",
            "* Під час операції `push`, коміти з гілки `master` переносяться у віддалений `master` (який локально представлений як `o/master`). *Гілка-призначення* для `push` визначена зв'язком між `master` і `o/master`.",
            ""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "## Гілки віддаленого стеження",
            "",
            "В двох словах, цей зв'язок між `master` та `o/master` і є тим \"віддаленим стеженням\", визначеним для гілки. Гілка `master` налаштована стежити за `o/master` -- це визначає неявну ціль для мерджу і неявне призначення під час операції `push` для гілки `master`.",
            "",
            "Ви можете подумати, а як же такий зв'язок було встановлено, якщо я не виконував жодної команди? Ну, коли гіт клонує репозиторій, він встановлює цей зв'язок автоматично.",
            "",
            "Під час клонування гіт створює гілки для стеження за кожною гілкою віддаленого репозиторію (напр. `o/master`). Потім він створює локальну гілку, що пов'язана і стежить за активною гілкою у віддаленому репозиторії, яка в більшості випадків називається `master`.",
            "",
            "Після закінчення клонування у вас буде лише одна локальна гілка (щоб не перевантажувати) але ви можете переглянути всі віддалені гілки (якщо буде цікаво). Такий собі розумний компроміс!",
            "",
            "Це пояснює чому ви бачите наступне повідомлення під час клонування:",
            "",
            "    local branch \"master\" set to track remote branch \"o/master\""
          ]
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### А можу я сам вибирати?",
            "",
            "Так, можеш! Ти можеш вибрати довільну гілку, яка слідкуватиме за `o/master`, і тоді для цієї гілки `push` та `merge` автоматично працюватимуть з `master`. Це означає, що виконання `git push` в гілці з назвою `totallyNotMaster` (зовсім не master) може зберегти локальні коміти у віддалену гілку `master`!",
            "",
            "Є два шляхи встановити такий зв'язок. Перший - створити нову гілку з явним вказанням зв'язку (за ким слідкувати). Виконання",
            "",
            "`git checkout -b totallyNotMaster o/master`",
            "",
            "створить гілку `totallyNotMaster`, яка слідкує за `o/master`."
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Досить розмов, подивімось в дії! Створімо нову гілку `foo` і змусьмо її слідкувати за віддаленою гілкою `master`."
          ],
          "afterMarkdowns": [
            "Як видно з результату, при оновленні `foo` було використано автоматичний зв'язок з `o/master` під час операції `merge`. Зверніть увагу, `master` не було оновлено!"
          ],
          "command": "git checkout -b foo o/master; git pull",
          "beforeCommand": "git clone; git fakeTeamwork"
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Це також справджується і для git push"
          ],
          "afterMarkdowns": [
            "Ка-бум!. Ми запушили наші зміни у віддалений `master`, незважаючи на те, що локальна гілка називалась зовсім по-іншому."
          ],
          "command": "git checkout -b foo o/master; git commit; git push",
          "beforeCommand": "git clone"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "### Спосіб №2",
            "",
            "Інший спосіб вказати за якою віддаленою гілкою слідкувати -- просто використовувати опцію `git branch -u`. Виконання",
            "",
            "`git branch -u o/master foo`",
            "",
            "заставить гілку `foo` слідкувати за `o/master`. Якщо `foo` є поточною гілкою, її можна навіть не вказувати:",
            "",
            "`git branch -u o/master`",
            ""
          ]
        }
      },
      {
        "type": "GitDemonstrationView",
        "options": {
          "beforeMarkdowns": [
            "Подивімось на цей спосіб швидко вказати віддалену гілку для відслідковування..."
          ],
          "afterMarkdowns": [
            "Як і перший спосіб, але своя окрема команда."
          ],
          "command": "git branch -u o/master foo; git commit; git push",
          "beforeCommand": "git clone; git checkout -b foo"
        }
      },
      {
        "type": "ModalAlert",
        "options": {
          "markdowns": [
            "Гаразд! На цьому рівні збережімо свою роботу у віддалену гілку `master` *без* переходу на локальну `master`. Про решту здогадайся сам, раз ти вже дойшов до цього рівня :P"
          ]
        }
      }
    ]
  },
  "sequence-intro-display": "Вступ",
  "sequence-intro-about": "Гарно підібране введення в основні команди git",
  "sequence-rampup-display": "Їдемо далі",
  "sequence-rampup-about": "Наступна порція абсолютної git-дивини. Сподіваюсь, ви зголодніли",
  "sequence-remote-display": "Push & Pull -- віддалені репозиторії в Git!",
  "sequence-remote-about": "Настав час поділитися своїми нулями та одиничками; соціальне програмування",
  "sequence-remote-advanced-display": "Через origin – до зірок. Прогресивне використання Git Remotes",
  "sequence-remote-advanced-about": "А ти думав, що бути всесильним диктатором весело...",
  "sequence-move-display": "Переміщуємо роботу туди-сюди",
  "sequence-move-about": "Не соромимось змінювати історію",
  "sequence-mixed-display": "Всяке",
  "sequence-mixed-about": "Різні прийоми роботи з Git, хитрощі та поради",
  "sequence-advanced-display": "Досвідчений рівень",
  "sequence-advanced-about": "Для хоробрих",
  "dialogs-confirm": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Впевнений, що хочеш побачити розв’язок?",
          "",
          "Я вірю в тебе! Ти впораєшся!"
        ]
      }
    }
  ],
  "dialogs-level-builder": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Ласкаво просимо до конструктора рівнів!",
          "",
          "Ось основні кроки:",
          "",
          "  * Налаштувати початкове середовище за допомогою команд git",
          "  * Визначити стартове дерево за допомогою ```define start```",
          "  * Ввести набір команд, що описують (оптимальний) розв’язок",
          "  * Визначити кінцеве дерево за допомогою ```define goal```. Одночасно це визначить розв’язок",
          "  * Додатково можна задати підказку за допомогою ```define hint```",
          "  * Редагувати назву рівня за допомогою ```define name```",
          "  * Додатково можна вказати файний початковий діалог за допомогою ```edit dialog```",
          "  * Ввести команду ```finish``` й отримати JSON з описом рівня!"
        ]
      }
    }
  ],
  "dialogs-next-level": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Молодець!",
          "",
          "Ти пройшов рівень. Кількість використаних команд — *{numCommands}*; ",
          "наш розв’язок складається з {best}."
        ]
      }
    }
  ],
  "dialogs-sandbox": [
    {
      "type": "ModalAlert",
      "options": {
        "markdowns": [
          "## Ласкаво просимо до Learn Git Branching",
          "",
          "Хочеш вивчити Git? Тоді ти знайшов те, що шукав!",
          "\"Learn Git Branching\" — це найбільш візуальний та інтерактивний спосіб вивчення Git в Інтернеті. ",
          "Ти зможеш проходити захопливі рівні, дивитися ",
          "покрокові інструкції з використання потужних функцій Git, навіть трохи ",
          "розважитись в процесі навчання.",
          "",
          "Після цього діалогу побачиш список доступних рівнів. Якщо ти новачок, ",
          "просто почни з першого рівня. Якщо вже знаєш основи Git, ",
          "спробуй більш складні рівні в кінці.",
          "",
          "P.S. Хочеш перейти одразу до пісочниці наступного разу?",
          "Спробуй ",
          "[це спеціальне посилання.](https://pcottle.github.io/learnGitBranching/?NODEMO)"
        ]
      }
    }
  ],
  "finish-dialog-finished": "Вау! Ти пройшов останній рівень, круто!",
  "finish-dialog-next": "Хочеш перейти на наступний рівень -- *\"{nextLevel}\"*?",
  "finish-dialog-win": "Чудово! Твій розв’язок на рівні або кращий від нашого.",
  "finish-dialog-lose": "Спробуй, можливо ти зможеш вкластися в {best} кроків :D",
  "hg-prune-tree": "Увага! Mercurial агресивно збирає сміття й може обрізати твоє дерево ",
  "hg-a-option": "Опція -A не потрібна для цього застосунку, можна просто комітити!",
  "hg-error-no-status": "Команда status не підтримується в цьому застосунку, так як немає стейджингу(staging) файлів. Натомість спробуй hg summary ",
  "hg-error-need-option": "Для цієї команди потрібна опція {option}",
  "hg-error-log-no-follow": "hg log без опції -f в данний момент не підтримується, використовуй -f",
  "git-status-detached": "Відокремлений HEAD",
  "git-status-onbranch": "В гілці {branch}",
  "git-status-readytocommit": "Готово до коміту! (як завжди в цьому демо)",
  "git-dummy-msg": "Швидкий коміт. Динамо!",
  "git-error-origin-fetch-uptodate": "Вже оновлено!",
  "git-error-origin-fetch-no-ff": "Твоя гілка origin не синхронізована з віддаленою гілкою, неможливо виконати fetch",
  "git-error-origin-push-no-ff": "Віддалений репозиторій розбігся з твоїм локальним репозиторієм, тому відвантаження твоїх змін не є простим fast forward (і тому твій push був відхилений). Будь-ласка, витягни зміни з віддаленого репозиторію, включи їх в цю гілку, й спробуй ще. Ти можеш зробити це за допомогою git pull чи git pull --rebase",
  "git-error-remote-branch": "Ти не можеш виконати цю команду на віддаленій гілці",
  "git-error-origin-required": "Для цієї команди потрібний origin",
  "git-error-origin-exists": "Origin вже існує! Неможливо створити ще один",
  "git-error-branch": "Неможливо видалити гілку master, гілку на якій ти зараз знаходишся чи штуки які не є гілкою",
  "git-merge-msg": "Злиття {target} в {current}",
  "git-error-rebase-none": "Нема комітів для rebase! Все в коміті злиття (merge commit) чи зміни вже застосовані",
  "git-result-nothing": "Нічого виконувати...",
  "git-result-fastforward": "Виконую Fast forward",
  "git-result-uptodate": "Гілку вже оновлено",
  "git-error-exist": "Посилання {ref} не існує чи невідоме",
  "git-error-relative-ref": "Коміт {commit} не містить {match}",
  "git-warning-detached": "Увага! Репозиторій в стані detached HEAD, тобто не знаходиться в жодній гілці!",
  "git-warning-add": "Не потрібно додавати файли для цього демо",
  "git-error-options": "Опції, які ти ввів, або некорректні або не підтримуються",
  "git-error-already-exists": "Коміт {commit} вже існує в твоєму change set, відміна!",
  "git-error-reset-detached": "Неможливо зробити reset в стані detached head! Використовуй checkout якщо хочеш змінити розташування",
  "git-warning-hard": "На LearnGitBranching reset по замовчуванню використовує --hard, тому цю опцію можна пропустити, якщо ти втомився її набирати щоразу. Тільки запам’ятай, що по замовчуванню звичайний git reset використовує --mixed",
  "git-error-staging": "В цьому демо немає можливості додати файл до робочої копії чи до стейджингу, тому ця опція чи команда некоректна чи не підтримується",
  "git-revert-msg": "Повертаю {oldCommit}: {oldMsg}",
  "git-error-args-many": "Я очікую максимум {upper} аргумент(ів) для {what}",
  "git-error-args-few": "Я очікую як мінімум {lower} аргумент(ів) для {what}",
  "git-error-no-general-args": "Ця команда не приймає загальних аргументів",
  "copy-tree-string": "Скопіюй рядок дерева нижче",
  "learn-git-branching": "Learn Git Branching",
  "select-a-level": "Обери рівень",
  "main-levels-tab": "Основи",
  "remote-levels-tab": "Віддалені репозиторії",
  "branch-name-short": "Вибач, нам потрібно щоб ім’я гілок було як можна коротше для наглядності. Твоє ім’я гілки було скорочене до 9 літер й тепер це \"{branch}\"",
  "bad-branch-name": "Назва гілки \"{branch}\" є недопустимою",
  "bad-tag-name": "Назва тегу \"{tag}\" є недопустимою",
  "option-not-supported": "Опція \"{option}\" не підтримується!",
  "git-usage-command": "git <команда> [<аргументи>]",
  "git-supported-commands": "Допустимі команди",
  "git-usage": "Використання:",
  "git-version": "Версія git PCOTTLE.1.0",
  "flip-tree-command": "Перевертаю дерево...",
  "refresh-tree-command": "Оновлюю дерево...",
  "locale-command": "Локаль тепер дорівнює {locale}",
  "locale-reset-command": "Локаль скинута. Тепер вона дорівнює {locale}",
  "show-command": "Щоб отримати більше інформації використовуй наступні команди:",
  "show-all-commands": "Ось список всіх можливих команд:",
  "cd-command": "Директорія змінена на \"/директорії/не/мають/значення/в/цьому/демо\"",
  "ls-command": "ЗабийНаФайлиВЦьомуДемо.txt",
  "mobile-alert": "LGB не підтримує ввід тексту з мобільного, зайди з компьютера! Це цього варте!",
  "share-tree": "Поділись цим деревом з друзями! Вони зможуть його завантажити за допомогою \"import tree\"",
  "paste-json": "Встав JSON нижче!",
  "solved-map-reset": "Все скинуте! Можна починати з чистого аркушу!",
  "level-cant-exit": "Ти не в рівні! Ти в пісочниці! Почни рівень з \"levels\"",
  "level-no-id": "Рівень з id \"{id}\" не знайдений! Відкриваю вибір рівней",
  "undo-stack-empty": "Нема куди відкатуватися",
  "already-solved": "Ти вже пройшов цей рівень, спробуй інші рівні з \"levels\" чи повернись в пісочницю з \"sandbox\"",
  "solved-level": "Вирішено!!\n:D",
  "command-disabled": "На цьому рівні не можна використовувати цю команду!",
  "share-json": "Ось JSON для цього рівня! Поділись з кимось чи відправ мені його на Github",
  "want-start-dialog": "Не вказано стартовий діалог, хочеш додати стартовий діалог?",
  "want-hint": "Не вказана підказка, хочеш додати підказку?",
  "prompt-hint": "Додай підказку для рівня, якщо хочеш",
  "prompt-name": "Введи назву рівня",
  "solution-empty": "Розв’язок порожній!! Щось не так",
  "define-start-warning": "Встановлюю стартову точку... розв’язок та ціль будуть переписані якщо вони були задані раніше",
  "help-vague-level": "При проходженні рівня доступні декілька різновидів допомоги. Виберіть або \"help level\" щоб взнати більше про цей рівень, чи \"help general\" щоб взнати більше про Learn Git Branching, чи \"objective\" щоб дізнатись більше про проходження цього рівня",
  "help-vague-builder": "При створенні рівня доступні декілька різновидів допомоги. Виберіть або \"help general\", чи \"help builder\"",
  "show-goal-button": "Ціль рівня",
  "hide-goal-button": "Сховати ціль",
  "objective-button": "Задача",
  "git-demonstration-title": "Git демо",
  "goal-to-reach": "Ціль рівня",
  "goal-only-master": "<span class=\"fwber\">Важливо:</span> В цьому рівні буде перевірятися тільки гілка master. Решта гілок тільки для наглядності (показані пунктиром нижче). Як завжди, можна сховати цей діалог за допомогою \"hide goal\"",
  "hide-goal": "Можна сховати це вікно за допомогою \"hide goal\"",
  "hide-start": "Можна сховати це вікно за допомогою \"hide start\"",
  "level-builder": "Редактор рівнів",
  "no-start-dialog": "Немає початкового діалогу для цього рівня!",
  "no-hint": "Хм, схоже для цього рівня немає підказки :-/",
  "error-untranslated-key": "Немає перекладу для {key} :( Будь-ласка, запропонуй переклад на Github",
  "error-untranslated": "Для цього повідомлення ще немає перекладу :( Будь-ласка, запропонуй переклад на Github"
}
